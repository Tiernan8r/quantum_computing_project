%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lachaise Assignment
% LaTeX Template
% Version 1.0 (26/6/2018)
%
% This template originates from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Marion Lachaise & François Févotte
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}
\usepackage{mathtools}
\usepackage{physics}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage[scale=1,bmargin=1.5cm,footnotesep=1.5cm]{geometry} %footnote spacing
\usepackage{float}
\usepackage{subcaption} %allows us to nest figures

\usepackage{hyperref} %enable hyperlinks 
\hypersetup{
    colorlinks=true,
    linkcolor=violet,
    filecolor=green,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

% To get references:
\usepackage[nottoc,numbib]{tocbibind} % To get bibliography into table of contents
\usepackage[backend=bibtex, style=ieee]{biblatex}
\bibliography{references} 

\urlstyle{same}

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------

\begin{document}
\onehalfspacing
\parindent=0pt          %  Switch off indent of paragraphs

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\thispagestyle{empty}

\vspace*{0.1\textheight}

\begin{center}
        \huge{\bfseries Quantum Computing Project Group 5}\\
\end{center}

\bigskip

\begin{center}
        \large{Jabeth Musumba}\\
        \large{Yi Sheng Ng}\\
        \large{Finn John Onori}\\
        \large{Tiernan Stapleton}\\
        \large{Riddhi Yadav}\\
        \large{Han Yoong}\\
        \bigskip
        \large{March 23, 2022}
\end{center}

\vspace*{0.4\textheight}

\begin{center}
        \includegraphics[width=35mm]{crest.pdf}
\end{center}

\medskip

\newpage

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------
\vspace{10mm}
\hrule

\vspace{10mm}

\section*{Introduction} % Unnumbered section
\vspace{10mm}

The objective of our project is to build an application which implements the Grover's Algorithm to perform an unstructured search from a list of information.
\vspace{5mm}

\noindent
The programming language used in our project is Python. We use Git to plan, manage and organise the codes and work flow of this project. 
\vspace{5mm}

\noindent
The aim of this project is to demonstrate the basic working principle of Grover's Algorithm in the shape of a simple GUI with input and output feature.
\vspace{5mm}

\noindent
In addition to the primary objective of this project, we have managed to successfully code and implement the Phase Estimation Algorithm and demonstrate the application of the Grover's Algorithm in solving simple Sudoku problems.
\pagebreak


\tableofcontents % Unnumbered section
\pagebreak

\section{Introduction to Quantum Computing}
\vspace{5mm}

\subsection{Qubits}
\vspace{5mm}

The qubit can be thought of as the "quantum" counterpart to the classical bit. 
\vspace{5mm}

\noindent
A bit is expressed in binary numbers of 0 and 1. In the most simple case of a classical bit, a bit can only be in the state of 0 or 1. However as for the quantum analogue, a qubit can be expressed in a superposition of both the binary state of 0 and 1.
\vspace{5mm}

\noindent
This superposition of state of a qubit $\ket{\psi}$ can be written as:
\vspace{5mm}

\begin{equation}
     \ket{\psi} = \alpha\ket{0} + \beta\ket{1}
\end{equation}
\vspace{5mm}

\noindent
Where $\alpha$ and $\beta$ are normalised complex constants such that $\abs{\alpha}^2 + \abs{\beta}^2 = 1$  for $\alpha, \ \beta \in \mathbb{C} $
\vspace{5mm}

\noindent
The quantum state of $\ket{0}$ and $\ket{1}$ are known as the computational basis state in the $\hat{\textbf{z}}$-axis on a Bloch Sphere. The basis state can be visualised in a form of a Bloch Sphere:
\vspace{5mm}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[scale=1.5]
    \clip(-2.19,-2.49) rectangle (2.66,2.58);
    \draw [shift={(0,0)}, lightgray, fill, fill opacity=0.1] (0,0) -- (56.7:0.4) arc (56.7:90.:0.4) -- cycle;
    \draw [shift={(0,0)}, lightgray, fill, fill opacity=0.1] (0,0) -- (-135.7:0.4) arc (-135.7:-33.2:0.4) -- cycle;
    \draw(0,0) circle (2cm);
    \draw [rotate around={0.:(0.,0.)},dash pattern=on 3pt off 3pt] (0,0) ellipse (2cm and 0.9cm);
    \draw (0,0)-- (0.70,1.07);
    \draw [->] (0,0) -- (0,2);
    \draw [->] (0,0) -- (-0.81,-0.79);
    \draw [->] (0,0) -- (2,0);
    \draw [dotted] (0.7,1)-- (0.7,-0.46);
    \draw [dotted] (0,0)-- (0.7,-0.46);
    \draw (-0.08,-0.3) node[anchor=north west] {$\varphi$};
    \draw (0.01,0.9) node[anchor=north west] {$\theta$};
    \draw (-1.01,-0.72) node[anchor=north west] {$\mathbf {\hat{x}}$};
    \draw (2.07,0.3) node[anchor=north west] {$\mathbf {\hat{y}}$};
    \draw (-0.5,2.6) node[anchor=north west] {$\mathbf {\hat{z}=|0\rangle}$};
    \draw (-0.4,-2) node[anchor=north west] {$-\mathbf {\hat{z}=|1\rangle}$};
    \draw (0.4,1.65) node[anchor=north west] {$|\psi\rangle$};
    \scriptsize
    \draw [fill] (0,0) circle (1.5pt);
    \draw [fill] (0.7,1.1) circle (0.5pt);
  \end{tikzpicture}
  \centering
\caption{\label{fig:bloch_sphere}The Bloch Sphere}
\end{figure}
\vspace{5mm}

\noindent
These qubit states can be expressed in column matrices as:
\vspace{5mm}

\begin{equation}
\ket{0} = \begin{pmatrix}1 \\ 0 \end{pmatrix} \ \ \text{and} \ \ \ket{1} = \begin{pmatrix} 0 \\ 1 \end{pmatrix}
\end{equation}

\vspace{5mm}

\noindent
The state of a quantum system can be represented as the spin, energy, angular momentum and magnetic moment of an elementary particle. However for the sake of brevity the state $\ket{0}$ and $\ket{1}$ will denote spin up and spin down of the electron in this report.
\vspace{10mm}

\subsection{Quantum Register}
\vspace{5mm}

\noindent
The qubits in a quantum computer are stored in a quantum register. The size of the quantum register is dictated by the number of qubits. 
\vspace{5mm}

\noindent
The vector state of the quantum register $\mathcal{H}$ with $n$ qubits can be expressed in tensor product \cite{noauthor_lecture_nodate}:
\vspace{5mm}


\qquad $\mathcal{H} = \mathbb{C}^{2\otimes N} = \mathbb{C}^2 \otimes\mathbb{C}^2 ....\otimes\mathbb{C}^2 = \mathbb{C}^{2^N} $ , \  where the qubits are in 2-dimensional complex spaces $\mathbb{C}$.
\vspace{5mm}

\noindent
Each qubit has an index in this register, starting at index 0 and counting up by 1. So, a system with 5 qubits, for example, has a qubit register that has a width of 5 and indexed by 0, 1, 2, 3 and 4.

\subsection{Tensor Product}
\vspace{5mm}

\noindent
Tensor product is used as a function which combines elements of two or more vector spaces to yield an additional vector space. 
\vspace{5mm}

\noindent
Tensor products are distributive and associative and shown here are the tensor products of two qubits $\ket{x}$ and $\ket{y}$, for $\alpha , \beta \in \mathbb{C}$, which obey such properties in the Hilbert space (complex vector space)\cite{noauthor_lecture_nodate}:
\vspace{5mm}


\begin{equation}
\alpha\ket{x} \otimes \beta\ket{y} = \alpha\beta\ket{xy}
\end{equation}
\vspace{5mm}


\begin{equation}\ket{x} \otimes (\ket{y} + \ket{z}) = \ket{x}\otimes \ket{y} + \ket{x}\otimes\ket{z}
\end{equation}
\vspace{5mm}


\begin{equation}
(\ket{x} + \ket{y}) \otimes \ket{z} = \ket{x}\otimes \ket{z} + \ket{y}\otimes\ket{z}
\end{equation}
\vspace{5mm}


\begin{equation}
(\ket{x} \otimes \ket{y}) \otimes \ket{z} = \ket{x} \otimes (\ket{y} \otimes\ket{z}) = \ket{x} \otimes \ket{y} \otimes\ket{z}
\end{equation}
\vspace{10mm}

The basis for the tensor product space is given by the product of single qubit basis states.
\vspace{5mm}

\begin{center}
$\ket{0}_2 \otimes \ket{0}_1 \otimes \ket{0}_0 = \ket{000} = \ket{0}$
\vspace{5mm}

$\ket{0}_2 \otimes \ket{0}_1 \otimes \ket{1}_0 = \ket{001} = \ket{1}$
\vspace{5mm}

$\cdots \cdots $

$\cdots \cdots$

$\cdots \cdots$
\vspace{5mm}

$\ket{1}_2 \otimes \ket{1}_1 \otimes \ket{1}_0 = \ket{111} = \ket{7}$
\end{center}
\vspace{5mm}

Little endian notation is used to represent the qubit from right to left starting with the subscript 0.

For ease of interpretation, the binary to decimal conversion is written on the right hand side. 
\vspace{10mm}

\subsection{Linear Algebra}
\vspace{5mm}

\noindent
Linear algebra is the language of quantum computing. It is the study of vector spaces and of linear operations on vector
spaces (Hilbert space).
\vspace{5mm}

\noindent
A generic quantum state $\ket{\psi}$ can be described as a linear combination of basis states such as \cite{noauthor_lecture_nodate}:
\vspace{5mm}


\begin{equation}
\ket{\psi} = \alpha_0\ket{0} + ... + \alpha_j\ket{j} = \sum\limits_{j = 0}^{j} \alpha_j\ket{j} , \ \text{for} \ \alpha_j \in \mathbb{C}
\end{equation}
\vspace{5mm}

\noindent
Due to the probabilistic nature of quantum mechanics, the state must be normalised, i.e $\sum\limits_j |\alpha_j|^2 = 1$
\vspace{5mm}

\noindent
The action of quantum operators on a state is linear. For a quantum operator $U$ acting on some state $\ket{x}$ and $\ket{y}$ can be expressed as:
\vspace{5mm}

\noindent
\begin{equation}
U(\alpha\ket{x} + \beta\ket{y}) = \alpha U\ket{x} + \beta U\ket{x} , \ \text{for} \ \alpha, \beta \in \mathbb{C}
\end{equation}
\vspace{5mm}

\noindent
The action of a quantum linear operator on a basis state determines the type of operator it is. It can also act on multiple or superposition of basis states:
\vspace{5mm}

\noindent
\begin{equation}
U \sum\limits_j \alpha_j \ket{j} = \sum\limits_j \alpha_j U\ket{j}
\end{equation}
\vspace{10mm}

\subsection{Matrix Operation}
\vspace{5mm}

\noindent
Linear operators $U$ acting on some basis states can be written in matrix form \cite{noauthor_lecture_nodate}:
\vspace{5mm}

\begin{equation}
U_{kj} = \bra{k}U\ket{j} \ , \text{for some basis state} \ket{j} \text{and} \ket{k} 
\end{equation}
\vspace{5mm}

\noindent
By using the Completeness Relation of quantum mechanics:
\vspace{5mm}

\begin{equation}
U\ket{j} = \underbrace{\sum\limits_k\ket{k}\bra{k}}_{ = 1} U\ket{j} = \sum\limits_k \ket{k} U_{kj}    
\end{equation}
\vspace{5mm}

\noindent
Multiple linear operators applied on a basis state can be written as:
\vspace{5mm}

\begin{equation}
UV\ket{k} = U\sum\limits_k \ket{k}V_{kj} = \sum\limits_l\ket{l} \sum\limits_k U_{lk} V_{kj} = \sum\limits_l(UV)_{lj}
\end{equation}
\vspace{5mm}

\noindent
The linear operator $U$ acting on the coefficient $\alpha$ of the vector state $\ket{\psi}$ can be expressed:
\vspace{5mm}

\begin{equation}
\alpha' = U\alpha
\end{equation}
\vspace{5mm}

\noindent
And on the state:
\vspace{5mm}

\begin{equation}
\ket{\psi'} = U\ket{\psi}
\end{equation}
\vspace{5mm}

\noindent
Additionally, all quantum operators (quantum gates) are unitary with the exception of measurement and reset operators. 
\vspace{5mm}

\noindent
A quantum operator $U$ has its conjugate transpose (adjoint) which can be expressed as $U^{\dagger}$.
\vspace{5mm}

\noindent
The unitary operator has the following property\cite{noauthor_unitary_2022}:
\vspace{5mm}

\begin{equation}
UU^{\dagger} = UU^{-1} = 1    
\end{equation}
\vspace{5mm}

\noindent
Another consequence of unitarity is that it preserves the inner product between two arbitrary states $\braket{\phi}{\psi}$. For example apply the unitary operator $U$ to two states $\ket{\phi}$ and $\ket{\psi}$:
\vspace{5mm}

\begin{equation}
\bra{\phi} U^{\dagger} U\ket{\psi} = \braket{\phi}{\psi}
\end{equation}
\vspace{5mm}

\noindent
the inner product of the resulting states is exactly the same,
\vspace{10mm}


\subsection{Gates and Operators}
\vspace{5mm}

Quantum gates are unitary quantum operators and are described as unitary matrices relative to some basis states.
\vspace{5mm}

\noindent
The following are some of the common types of quantum gates\cite{voorhoede_pauli-x_nodate} which will be used in constructing the Grover's circuit.
\vspace{5mm}

\textbf{Hadamard Gate}: \qquad $H = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$
\vspace{5mm}

\noindent
The Hadamard gate creates a superposition states when acted on a state:
\vspace{5mm}


\begin{equation}
H\ket{0} = \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}), \ \ H\ket{1} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})   
\end{equation}
\vspace{5mm}

\noindent
This can then be generalised as:
\vspace{5mm}

\begin{equation}
H\ket{j} = \frac{-1^j\ket{j} + \ket{1 - j}}{\sqrt{2}} 
\end{equation}
\vspace{5mm}


\textbf{Pauli X Gate}: \qquad $X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}$
\vspace{5mm}


\begin{equation}
X\ket{0} = \ket{1} , \ \ X\ket{1} = \ket{0}
\end{equation}
\vspace{5mm}

\noindent
The Pauli X Gate acts very similar to a classical NOT gate. This effect of this gate is also known as bit flip. The gate is a single qubit rotation around the x-axis by $\pi$.
\vspace{5mm}


\textbf{Pauli Y Gate}: \qquad $Y = \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}$
\vspace{5mm}


\begin{equation}
Y\ket{0} = i\ket{1} , \ \ Y\ket{1} = -i\ket{0}
\end{equation}
\vspace{5mm}

\noindent
The Pauli Y Gate rotates a single qubit in the y (complex)-axis by $\pi$.
\vspace{5mm}


\textbf{Pauli Z Gate}: \qquad $Z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}$
\vspace{5mm}


\begin{equation}
Z\ket{0} = \ket{0} , \ \ Z\ket{1} = -\ket{1}  
\end{equation}
\vspace{5mm}

\noindent
The Pauli-Z gate is a single qubit rotation through $\pi$ radians around the z-axis. The effect of the Pauli Z Gate is also known as phase-flip.
\vspace{5mm}

\textbf{Controlled Not/CNOT Gate}: \qquad CNOT = $\begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix}$
\vspace{5mm}

\noindent
The CNOT Gate is a two qubit gate which takes the first qubit as the control qubit and the second qubit as the target qubit.
\vspace{5mm}

\noindent
It leaves the control qubit unchanged and performs the Pauli X Gate to the target qubit if and only if when the control qubit is $\ket{1}$ and leaves the target qubit unchanged when the control qubit is $\ket{0}$.
\vspace{5mm}

\textbf{Controlled Z/CZ Gate}: \qquad CZ = $\begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & -1 \end{pmatrix}$
\vspace{5mm}

\noindent
The CZ Gate is a two qubit gate which takes the first qubit as the control qubit and the second qubit as the target qubit.
\vspace{5mm}

\noindent
It leaves the control qubit unchanged and performs the Pauli Z Gate to the target qubit if and only if when the control qubit is $\ket{1}$ and leaves the target qubit unchanged when the control qubit is $\ket{0}$.
\pagebreak

\textbf{Phase Shift Gates}: \qquad $ P(\varphi) = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\varphi} \end{pmatrix}$ 
\vspace{5mm}

\begin{equation}
P(\varphi)\ket{0} = \ket{0} \ \text{and} \ P(\varphi)\ket{1} = e^{i\varphi}\ket{1} 
\end{equation}

\noindent
The phase shift gate modifies the phase of the quantum state and is equivalent to tracing a horizontal circle on the Bloch Sphere (see Figure \ref{fig:bloch_sphere}) by $\varphi$ radians\cite{noauthor_quantum_nodate}. 

\pagebreak

\section{Grover's Algorithm}
\subsection{Introduction}

The Grover's Algorithm is a quantum search algorithm which increases quadratically the speed of unstructured search\cite{noauthor_grovers_nodate}. It uses  amplitude amplification to search an unstructured set of $N$ elements/items. 

\subsection{Unstructured Search}
\vspace{10mm}

\begin{figure}[h]
  \begin{center}

    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
      %uncomment if require: \path (0,310); %set diagram left start at 0, and has height of 310

      %Shape: Axis 2D [id:dp7326811016330554] 
      \draw  (54,256.57) -- (514,256.57)(100,150.37) -- (100,268.37) (507,251.57) -- (514,256.57) -- (507,261.57) (95,157.37) -- (100,150.37) -- (105,157.37)  ;
      %Shape: Rectangle [id:dp9165080769461678] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (100,220) -- (123.02,220) -- (123.02,256.57) -- (100,256.57) -- cycle ;
      %Shape: Rectangle [id:dp6197087457024866] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (123.02,220) -- (146.04,220) -- (146.04,256.57) -- (123.02,256.57) -- cycle ;
      %Shape: Rectangle [id:dp5818508515663341] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (146.04,220) -- (169.06,220) -- (169.06,256.57) -- (146.04,256.57) -- cycle ;
      %Shape: Rectangle [id:dp6466988498042014] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (169.06,220) -- (192.08,220) -- (192.08,256.57) -- (169.06,256.57) -- cycle ;
      %Shape: Rectangle [id:dp9241747490680354] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (192.08,220) -- (215.1,220) -- (215.1,256.57) -- (192.08,256.57) -- cycle ;
      %Shape: Rectangle [id:dp6900943731279547] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (215.1,220) -- (238.12,220) -- (238.12,256.57) -- (215.1,256.57) -- cycle ;
      %Shape: Rectangle [id:dp9784662305616809] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (238.12,220) -- (261.14,220) -- (261.14,256.57) -- (238.12,256.57) -- cycle ;
      %Shape: Rectangle [id:dp3189854749942387] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (261.14,220) -- (284.16,220) -- (284.16,256.57) -- (261.14,256.57) -- cycle ;
      %Shape: Rectangle [id:dp19644432939638312] 
      \draw  [fill={rgb, 255:red, 208; green, 2; blue, 27 }  ,fill opacity=1 ] (284.04,220) -- (307.06,220) -- (307.06,256.57) -- (284.04,256.57) -- cycle ;
      %Shape: Rectangle [id:dp4454731461786199] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (307.06,220) -- (330.08,220) -- (330.08,256.57) -- (307.06,256.57) -- cycle ;
      %Shape: Rectangle [id:dp8963311487850567] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (330.08,220) -- (353.1,220) -- (353.1,256.57) -- (330.08,256.57) -- cycle ;
      %Shape: Rectangle [id:dp8621164913285171] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (353.1,220) -- (376.12,220) -- (376.12,256.57) -- (353.1,256.57) -- cycle ;
      %Shape: Rectangle [id:dp7667099225825136] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (376.12,220) -- (399.14,220) -- (399.14,256.57) -- (376.12,256.57) -- cycle ;
      %Shape: Rectangle [id:dp1405504024872024] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (399.14,220) -- (422.16,220) -- (422.16,256.57) -- (399.14,256.57) -- cycle ;
      %Shape: Rectangle [id:dp6549374163542783] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (422.16,220) -- (445.18,220) -- (445.18,256.57) -- (422.16,256.57) -- cycle ;
      %Shape: Rectangle [id:dp26369533307147797] 
      \draw  [fill={rgb, 255:red, 155; green, 155; blue, 155 }  ,fill opacity=1 ] (445.18,220) -- (468.2,220) -- (468.2,256.57) -- (445.18,256.57) -- cycle ;

      % Text Node
      \draw (491,261) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize elements/items}};
      % Text Node
      \draw (61,131) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize Amplitude}};
      % Text Node
      \draw (109,262) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {1};
      % Text Node
      \draw (129,262) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {2};
      % Text Node
      \draw (171,262) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {................................};
      % Text Node
      \draw (151,262) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {3};
      % Text Node
      \draw (311,262) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {................................};
      % Text Node
      \draw (291,262) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize] [align=left] {$\displaystyle \omega $};
      % Text Node
      \draw (436,262) node [anchor=north west][inner sep=0.75pt]   [align=left] {N};

    \end{tikzpicture}    
  \end{center}
  \caption{\label{fig:intial_quantum_state} The initial quantum state}
\end{figure}

\vspace{10mm}
\noindent
An unstructured search through a list of items using Grover's Algorithm can be illustrated in Figure1. In this instance, $\omega$ the red block, represents the item which we want to find and $N$ represents the number of items in the list. 
\vspace{5mm}

\noindent
On classical computation, $\omega$ must check at least on average $O(N/2)$ entries of the list which gives $\frac{1}{2}$ the probability of finding $\omega$ or worse the entire N elements in the list.
With Grover's Algorithm, only $O(\sqrt{N})$ steps are required to find $\omega$.
\vspace{5mm}

\noindent
For an $N$ item search problem with $M$ number of solutions, the required number of times of searches will be $O(\sqrt{\frac{N}{M}})$\cite{nielsen_quantum_2010}.
\pagebreak

\subsection{The Oracle} \label{The Oracle}
\vspace{5mm}

Let's suppose the function $f$ of $N$ integer such that $f:\{0,1, 2,...., N-1\} \rightarrow{\{0,1\}}$. 
\vspace{5mm}

\noindent
The integers in the domain corresponds to the indices of the list and $f(x) =1$ if and only if $x$ corresponds to the item which is to be searched. Conversely, $f(x) =0$ for $x$ not corresponding to the item to be searched. 
\vspace{5mm}

\noindent
There will be only one value of $x$ which satisfies $f(x)=1$ and this index corresponds to item $\omega$\cite{noauthor_grovers_2022}.
\vspace{5mm}

\noindent
So $f$ can be accessed with a unitary operator $U_{\omega}$ of  an oracle which satisfies:
\vspace{5mm}

\begin{equation}
\begin{cases}
      U_{\omega}\ket{x} = -\ket{x}  & \text{for} \ x = \omega, \ f(x) =1 \\
       U_{\omega}\ket{x} = \ket{x}  & \text{for} \ x \neq \omega, \ f(x) = 0 \\
\end{cases}  
\end{equation}

\vspace{5mm}

The oracle function of a two qubit system is defined as\cite{j_quantum_2020}:
\vspace{5mm}

\begin{equation}
\ket{x} \otimes \ket{q} \rightarrow{O_f} \ket{x} \otimes \ket{q \oplus f(x)} \footnote{$\otimes$ denotes tensor product and $\oplus$ denotes denotes addition modulo 2}  
\end{equation}

\vspace{5mm}

\begin{equation}
\ket{q} = \frac{\ket{0} - \ket{1}}{\sqrt{2}}
\end{equation}
\vspace{5mm}

Substitute $\ket{q}$ into the oracle function $O_f$:
\vspace{5mm}

\begin{equation}
 O\ket{x}\frac{\ket{0} - \ket{1}}{\sqrt{2}} \rightarrow \ket{x} \frac{\ket{f(x) \oplus 0} - \ket{f(x) \oplus 1}}{\sqrt{2}}    
\end{equation}
\vspace{5mm}

\begin{equation}
\text{if} \ f(x) =1 \rightarrow \ket{x}\frac{\ket{f(x) \oplus0} - \ket{f(x) \oplus1}}{\sqrt{2}}   
\end{equation}
\vspace{5mm}

\begin{equation}
\text{if} \ f(x) =1 \rightarrow \ket{x}\frac{\ket{1 \oplus 0} - \ket{1 \oplus 1}}{\sqrt{2}} = -\ket{x}\frac{\ket{0} - \ket{1}}{\sqrt{2}}    
\end{equation}
\vspace{5mm}

\begin{equation}
\text{if} \ f(x) =0 \rightarrow \ket{x}\frac{\ket{0 \oplus 0} - \ket{0 \oplus 1}}{\sqrt{2}} = \ket{x}\frac{\ket{0} - \ket{1}}{\sqrt{2}}    
\end{equation}
\vspace{5mm}

\noindent
When $f(x) = 1 $, the amplitude $\ket{x}$ changed to negative and remains unchanged when $f(x) = 0$.
\vspace{5mm}

\noindent
The oracle takes the form of a diagonal matrix $U_{\omega}$
\vspace{5mm}
\noindent
For example, in a three qubit state, we want to look for the number 6 which corresponds to $\ket{110}$. In matrix form $\omega =6$ will be:
\vspace{5mm}

\qquad $ U_\omega = \begin{bmatrix}

1 & 0 & 0 & 0 & 0& 0 & 0& 0 \\
0 & 1 & 0 & 0 & 0& 0 & 0& 0 \\
0 & 0 & 1 & 0 & 0& 0 & 0& 0 \\
0 & 0 & 0 & 1 & 0& 0 & 0& 0 \\
0 & 0 & 0 & 0 & 1& 0 & 0& 0 \\
0 & 0 & 0 & 0 & 0& 1 & 0& 0 \\
0 & 0 & 0 & 0 & 0& 0 & -1& 0 \\
0 & 0 & 0 & 0 & 0& 0 & 0& 1 \\

\end{bmatrix}$
\vspace{5mm}

Hence the oracle can be described as:
\vspace{5mm}

\begin{equation}
U_\omega\ket{x} = (-1)^{f(x)} \ket{x}    
\end{equation}
\vspace{5mm}

This is essentially a reflection on the state $\ket{x}$.

\pagebreak

\subsection{How The Algorithm Works} \label{How the Algorithm Works}
\vspace{5mm}

\textbf{Step 1:}
\vspace{5mm}
\noindent
The sequence of the Grover's Algorithm starts out with a uniform superposition state $\ket{s}$\cite{noauthor_grovers_nodate}:
\vspace{5mm}

\begin{equation}
\ket{s}= H^{\otimes n} \ket{0}^n = \frac{1}{\sqrt{2^n}}\sum\limits_{x \in \{0,1\}^n}\ket{x}
\end{equation}
\vspace{5mm}

\qquad For $N = 2^n$ , where $n$ is the number of qubits.
\vspace{5mm}


\begin{figure}[h]
  \begin{subfigure}{.5\textwidth}
    \centering
    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt

    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
      % uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

      %Shape: Axis 2D [id:dp05560542711234939] 
      \draw  (50,247.9) -- (308,247.9)(75.8,112) -- (75.8,263) (301,242.9) -- (308,247.9) -- (301,252.9) (70.8,119) -- (75.8,112) -- (80.8,119)  ;
      %Shape: Boxed Line [id:dp13553556978051007] 
      \draw    (75.8,247.9) -- (298.07,185.84) ;
      \draw [shift={(300,185.3)}, rotate = 164.4] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

      % Text Node
      \draw (82,87.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{\omega }$};
      % Text Node
      \draw (306,167.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{s}$};
      % Text Node
      \draw (307,253.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{s'}$};
      % Text Node
      \draw (181,220.4) node [anchor=north west][inner sep=0.75pt]    {$\theta $};

    \end{tikzpicture}

    \caption{\label{fig:grover_step_1a} Grover's Algorithm Step 1a}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
      %uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

      %Shape: Axis 2D [id:dp29246180096889995] 
      \draw  (390,249.6) -- (597,249.6)(410.7,111) -- (410.7,265) (590,244.6) -- (597,249.6) -- (590,254.6) (405.7,118) -- (410.7,111) -- (415.7,118)  ;
      %Shape: Rectangle [id:dp09588343067912675] 
      \draw   (410.7,198) -- (431,198) -- (431,249.6) -- (410.7,249.6) -- cycle ;
      %Shape: Rectangle [id:dp06589745305688277] 
      \draw   (431,198) -- (451.3,198) -- (451.3,249.6) -- (431,249.6) -- cycle ;
      %Shape: Rectangle [id:dp1570793013008731] 
      \draw   (451.3,198) -- (471.6,198) -- (471.6,249.6) -- (451.3,249.6) -- cycle ;
      %Shape: Rectangle [id:dp04465276081897107] 
      \draw   (471.6,198) -- (491.9,198) -- (491.9,249.6) -- (471.6,249.6) -- cycle ;
      %Shape: Rectangle [id:dp3205832207723005] 
      \draw   (491.9,198) -- (512.2,198) -- (512.2,249.6) -- (491.9,249.6) -- cycle ;
      %Shape: Rectangle [id:dp7965850817244042] 
      \draw  [fill={rgb, 255:red, 144; green, 19; blue, 254 }  ,fill opacity=1 ] (512.2,198) -- (532.5,198) -- (532.5,249.6) -- (512.2,249.6) -- cycle ;
      %Shape: Rectangle [id:dp41205715411636223] 
      \draw   (532.5,198) -- (552.8,198) -- (552.8,249.6) -- (532.5,249.6) -- cycle ;
      %Shape: Rectangle [id:dp6260805143227606] 
      \draw   (552.8,198) -- (573.1,198) -- (573.1,249.6) -- (552.8,249.6) -- cycle ;

      % Text Node
      \draw (405,84) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize Amplitude}};
      % Text Node
      \draw (412.7,252.6) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize 0}};
      % Text Node
      \draw (586,176.4) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize]  {$\frac{1}{\sqrt{2^{n}}}$};
      % Text Node
      \draw (560,256) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize N}};
      % Text Node
      \draw (602,251) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize items}};
      % Text Node
      \draw (508.2,254.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{\omega }$};

    \end{tikzpicture}
    \caption{\label{fig:grover_step_1b} Grover's Algorithm Step 1b}
  \end{subfigure}
  \caption{\label{fig:grover_step_1} Grover's Algorithm Step 1}
\end{figure}
\vspace{5mm}

Figure \ref{fig:grover_step_1a} shows a two dimensional plane spanned by $\ket{\omega}$ and $\ket{s'}$. In this representation, it can be written:
\vspace{5mm}

\begin{equation}
\ket{s} = \sin\theta\ket{\omega} + \cos\theta\ket{s'}   
\end{equation}
\vspace{5mm}

\begin{equation}
\sin\theta = \frac{1}{\sqrt{2^n}}    
\end{equation}
\vspace{5mm}

Where the amplitude of $\ket{s}$ is as shown in Figure \ref{fig:grover_step_1b}.
\pagebreak

\textbf{Step 2:}
\vspace{5mm}
Next apply the reflection oracle $U_\omega$ to the state $\ket{s}$.
\vspace{5mm}


\begin{figure}[h]
  \begin{subfigure}{0.5\textwidth}
    \centering
    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
    
    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
        %uncomment if require: \path (0,421); %set diagram left start at 0, and has height of 421
        
        %Shape: Axis 2D [id:dp9468133521588677] 
        \draw  (50,250.9) -- (308,250.9)(75.8,115) -- (75.8,266) (301,245.9) -- (308,250.9) -- (301,255.9) (70.8,122) -- (75.8,115) -- (80.8,122)  ;
        %Shape: Boxed Line [id:dp05857323871196929] 
        \draw    (75.8,250.9) -- (300.2,191.51) ;
        \draw [shift={(302.13,191)}, rotate = 165.18] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
        %Shape: Boxed Line [id:dp6041685570388957] 
        \draw [color={rgb, 255:red, 208; green, 2; blue, 27 }  ,draw opacity=1 ][fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ][line width=1.5]    (75.8,250.9) -- (296.23,308.24) ;
        \draw [shift={(299.13,309)}, rotate = 194.58] [color={rgb, 255:red, 208; green, 2; blue, 27 }  ,draw opacity=1 ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
        %Shape: Arc [id:dp7847818797073434] 
        \draw  [draw opacity=0][dash pattern={on 4.5pt off 4.5pt}] (243.13,206.74) .. controls (255.6,216.75) and (261.2,241.7) .. (255.64,263.91) .. controls (252.12,278.01) and (244.9,287.75) .. (236.73,291.16) -- (231.03,247.47) -- cycle ; \draw  [dash pattern={on 4.5pt off 4.5pt}] (243.13,206.74) .. controls (255.6,216.75) and (261.2,241.7) .. (255.64,263.91) .. controls (252.12,278.01) and (244.9,287.75) .. (236.73,291.16) ;  
        \draw   (262.62,257.57) -- (254.59,267.79) -- (251.53,255.15) ;
        %Shape: Arc [id:dp2964811498005937] 
        \draw  [draw opacity=0] (140.64,251.2) .. controls (144.47,252.64) and (147.27,256.11) .. (147.38,260.04) .. controls (147.48,263.72) and (145.19,266.77) .. (141.81,268.01) -- (137.59,259.56) -- cycle ; \draw   (140.64,251.2) .. controls (144.47,252.64) and (147.27,256.11) .. (147.38,260.04) .. controls (147.48,263.72) and (145.19,266.77) .. (141.81,268.01) ;  
        
        % Text Node
        \draw (70,90.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{\omega }$};
        % Text Node
        \draw (303,185.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{s}$};
        % Text Node
        \draw (307,256.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{s'}$};
        % Text Node
        \draw (157,255.4) node [anchor=north west][inner sep=0.75pt]    {$\theta $};
        % Text Node
        \draw (300,302.4) node [anchor=north west][inner sep=0.75pt]    {$U_{\omega }\ket{s}$};
    \end{tikzpicture}
    
    \caption{\label{fig:grover_step_2a} Grover's Algorithm Step 2a}
  \end{subfigure}%
  \begin{subfigure}{0.5\textwidth}
      \centering
      \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
      
      \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
        %uncomment if require: \path (0,421); %set diagram left start at 0, and has height of 421
      
        %Shape: Axis 2D [id:dp13230548671390374] 
      \draw  (388,254.6) -- (595,254.6)(408.7,116) -- (408.7,270) (588,249.6) -- (595,254.6) -- (588,259.6) (403.7,123) -- (408.7,116) -- (413.7,123)  ;
%Shape: Rectangle [id:dp05277599517068765] 
\draw   (408.7,216.67) -- (429,216.67) -- (429,254.6) -- (408.7,254.6) -- cycle ;
%Shape: Rectangle [id:dp9567149694615606] 
\draw   (429,216.67) -- (449.3,216.67) -- (449.3,254.6) -- (429,254.6) -- cycle ;
%Shape: Rectangle [id:dp33156724904270707] 
\draw   (449.3,216.67) -- (469.6,216.67) -- (469.6,254.6) -- (449.3,254.6) -- cycle ;
%Shape: Rectangle [id:dp7921289702689205] 
\draw   (469.6,216.67) -- (489.9,216.67) -- (489.9,254.6) -- (469.6,254.6) -- cycle ;
%Shape: Rectangle [id:dp7099186384950043] 
\draw   (489.9,216.67) -- (510.2,216.67) -- (510.2,254.6) -- (489.9,254.6) -- cycle ;
%Shape: Rectangle [id:dp6243887993660082] 
\draw  [fill={rgb, 255:red, 144; green, 19; blue, 254 }  ,fill opacity=1 ] (510.2,254.6) -- (530.5,254.6) -- (530.5,294.33) -- (510.2,294.33) -- cycle ;
%Shape: Rectangle [id:dp9966482917344106] 
\draw   (530.5,216.67) -- (550.8,216.67) -- (550.8,254.6) -- (530.5,254.6) -- cycle ;
%Shape: Rectangle [id:dp29247452792340645] 
\draw  [dash pattern={on 4.5pt off 4.5pt}]  (396.13,205) -- (577.13,205) ;
        
        % Text Node
        \draw (395,100) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize Amplitude}};
        % Text Node
        \draw (410,260) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize 0}};
        % Text Node
        \draw (586,195) node [anchor=north west][inner sep=0.75pt]  [font=\footnotesize]  {$\frac{1}{\sqrt{2^{n}}}$};
        % Text Node
        \draw (560,256) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize N}};
        % Text Node
        \draw (602,251) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize items}};
        % Text Node
        \draw (509.2,300) node [anchor=north west][inner sep=0.75pt]    {$\ket{\omega }$};
    
      \end{tikzpicture}
      
      \caption{\label{fig:grover_step_2b} Grover's Algorithm Step 2b}
  \end{subfigure}
  \caption{\label{fig:grover_step_2} Grover's Algorithm Step 2}
\end{figure}
\vspace{5mm}

The reflection oracle $U_\omega$ can be expressed as:
\vspace{5mm}

\begin{equation}
U_\omega = 1 - 2\ket{\omega}\bra{\omega}    
\end{equation}

\vspace{5mm}

\begin{equation}
U_\omega \ket{s} = -\sin\theta\ket{\omega} +  \cos\theta\ket{\omega}    
\end{equation} 
\vspace{5mm}

\noindent
$U_{{\omega }}$ is a reflection at the hyperplane orthogonal to $\ket{\omega}$  for vectors in the plane spanned by $\ket{s'}$  and $\ket{\omega}$\cite{noauthor_grovers_2022}.
\vspace{5mm}

\noindent
Referring to Figure \ref{fig:grover_step_2a}, $\ket{s}$ is reflected about $\ket{s'}$. The reflection operation on $\ket{s}$ in the negative amplitude causes the overall positive average amplitude to decrease slightly as indicated by Figure \ref{fig:grover_step_2b}. 
\pagebreak

\textbf{Step 3:}
\vspace{5mm}

\begin{figure}[h]
  \begin{subfigure}{.5\textwidth}
    \centering
    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
      %uncomment if require: \path (0,421); %set diagram left start at 0, and has height of 421

      %Shape: Axis 2D [id:dp1077584187321754] 
      \draw  (50,245) -- (308,245)(75.8,56) -- (75.8,266) (301,240) -- (308,245) -- (301,250) (70.8,63) -- (75.8,56) -- (80.8,63)  ;
      %Shape: Boxed Line [id:dp16066044861623174] 
      \draw    (75.8,245) -- (300.2,185.61) ;
      \draw [shift={(302.13,185.1)}, rotate = 165.18] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
      %Shape: Boxed Line [id:dp9706672155769875] 
      \draw [draw opacity=1 ][fill opacity=1 ][line width=1.5]    (75.8,245) -- (296.23,302.34) ;
      \draw [shift={(299.13,303.1)}, rotate = 194.58] [draw opacity=1 ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
      %Shape: Arc [id:dp872952775851549] 
      \draw  [draw opacity=0][dash pattern={on 4.5pt off 4.5pt}] (198.95,95.79) .. controls (242.68,120.59) and (271.35,171.76) .. (265.48,219.88) .. controls (261.92,249.01) and (246.41,271.27) .. (224.47,283.34) -- (164.47,187.12) -- cycle ; \draw  [dash pattern={on 4.5pt off 4.5pt}] (198.95,95.79) .. controls (242.68,120.59) and (271.35,171.76) .. (265.48,219.88) .. controls (261.92,249.01) and (246.41,271.27) .. (224.47,283.34) ;  
      \draw   (248.03,152.19) -- (245.19,139.5) -- (256.91,145.12) ;
      %Shape: Arc [id:dp6976856692056519] 
      \draw  [draw opacity=0] (142.64,228.2) .. controls (146.47,229.64) and (149.27,233.11) .. (149.38,237.04) .. controls (149.48,240.72) and (147.19,243.77) .. (143.81,245.01) -- (139.59,236.56) -- cycle ; \draw   (142.64,228.2) .. controls (146.47,229.64) and (149.27,233.11) .. (149.38,237.04) .. controls (149.48,240.72) and (147.19,243.77) .. (143.81,245.01) ;  
      %Shape: Boxed Line [id:dp005988885245785669] 
      \draw [color={rgb, 255:red, 208; green, 2; blue, 27 }  ,draw opacity=1 ][fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ][line width=1.5]    (75.8,245) -- (223.22,67.41) ;
      \draw [shift={(225.13,65.1)}, rotate = 129.7] [color={rgb, 255:red, 208; green, 2; blue, 27 }  ,draw opacity=1 ][line width=1.5]    (14.21,-4.28) .. controls (9.04,-1.82) and (4.3,-0.39) .. (0,0) .. controls (4.3,0.39) and (9.04,1.82) .. (14.21,4.28)   ;
      %Shape: Arc [id:dp47337907989211914] 
      \draw  [draw opacity=0] (138.23,172.51) .. controls (151.09,175.41) and (161.57,183.15) .. (165.41,194.07) .. controls (168.83,203.79) and (166.27,214) .. (159.46,222.26) -- (123.73,205.22) -- cycle ; \draw   (138.23,172.51) .. controls (151.09,175.41) and (161.57,183.15) .. (165.41,194.07) .. controls (168.83,203.79) and (166.27,214) .. (159.46,222.26) ;  

      % Text Node
      \draw (63,34.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{\omega }$};
      % Text Node
      \draw (303,185.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{s}$};
      % Text Node
      \draw (307,256.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{s'}$};
      % Text Node
      \draw (173,226.4) node [anchor=north west][inner sep=0.75pt]    {$\theta $};
      % Text Node
      \draw (235,54.4) node [anchor=north west][inner sep=0.75pt]    {$U_{s} U_{\omega }\ket{s}$};
      % Text Node
      \draw (177,170.4) node [anchor=north west][inner sep=0.75pt]    {$2\theta $};

    \end{tikzpicture}
    \caption{\label{fig:grover_step_3a} Grover's Algorithm Step 3a}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
      %uncomment if require: \path (0,421); %set diagram left start at 0, and has height of 421

      %Shape: Axis 2D [id:dp9734077209252769] 
      \draw  (390,249.6) -- (597,249.6)(410.7,111) -- (410.7,265) (590,244.6) -- (597,249.6) -- (590,254.6) (405.7,118) -- (410.7,111) -- (415.7,118)  ;
      %Shape: Rectangle [id:dp3704883525061837] 
      \draw   (410.7,211.67) -- (431,211.67) -- (431,249.6) -- (410.7,249.6) -- cycle ;
      %Shape: Rectangle [id:dp044532975443389855] 
      \draw   (431,211.67) -- (451.3,211.67) -- (451.3,249.6) -- (431,249.6) -- cycle ;
      %Shape: Rectangle [id:dp7877425682227512] 
      \draw   (451.3,211.67) -- (471.6,211.67) -- (471.6,249.6) -- (451.3,249.6) -- cycle ;
      %Shape: Rectangle [id:dp9424861909526165] 
      \draw   (471.6,211.67) -- (491.9,211.67) -- (491.9,249.6) -- (471.6,249.6) -- cycle ;
      %Shape: Rectangle [id:dp22778928407890264] 
      \draw   (491.9,211.67) -- (512.2,211.67) -- (512.2,249.6) -- (491.9,249.6) -- cycle ;
      %Shape: Rectangle [id:dp5422997780895953] 
      \draw  [fill={rgb, 255:red, 144; green, 19; blue, 254 }  ,fill opacity=1 ] (512.2,249.6) -- (532.5,249.6) -- (532.5,162) -- (512.2,162) -- cycle ;
      %Shape: Rectangle [id:dp7263987108332439] 
      \draw   (532.5,211.67) -- (552.8,211.67) -- (552.8,249.6) -- (532.5,249.6) -- cycle ;
      %Shape: Rectangle [id:dp5179786757543001] 
      \draw   (552.8,211.67) -- (573.1,211.67) -- (573.1,249.6) -- (552.8,249.6) -- cycle ;
      %Straight Lines [id:da21954100641972407] 
      \draw  [dash pattern={on 4.5pt off 4.5pt}]  (398.13,200) -- (579.13,200) ;

      % Text Node
      \draw (405,84) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize Amplitude}};
      % Text Node
      \draw (412.7,252.6) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize 0}};
      % Text Node
      \draw (560,256) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize N}};
      % Text Node
      \draw (602,251) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\footnotesize items}};
      % Text Node
      \draw (507.2,138.07) node [anchor=north west][inner sep=0.75pt]    {$\ket{\omega }$};
      % Text Node
      \draw (530,135) node [anchor=north west][inner sep=0.75pt]    {$ >\ \frac{1}{\sqrt{2^{n}}}$};

    \end{tikzpicture}
    \caption{\label{fig:grover_step_3b} Grover's Algorithm Step 3b}
  \end{subfigure}
  \caption{\label{fig:grover_step_3} Grover's Algorithm Step 3}
\end{figure}
\vspace{10mm}

\noindent
As indicated in Figure \ref{fig:grover_step_3a}, a diffusion operator $U_s$ is applied which results in a rotation of $\ket{s}$ by $2\theta$. 
\pagebreak


\begin{figure}
\begin{center}
      
    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
    %uncomment if require: \path (0,392); %set diagram left start at 0, and has height of 392

    %Shape: Rectangle [id:dp8937257723636158] 
    \draw  [fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (143,134) -- (175.19,134) -- (175.19,162.7) -- (143,162.7) -- cycle ;
    %Shape: Rectangle [id:dp007021083049765675] 
    \draw  [fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (143,174.3) -- (175.19,174.3) -- (175.19,203) -- (143,203) -- cycle ;
    %Shape: Rectangle [id:dp8911339020880464] 
    \draw  [fill={rgb, 255:red, 248; green, 231; blue, 28 }  ,fill opacity=1 ] (205,133) -- (235,133) -- (235,203) -- (205,203) -- cycle ;
    %Shape: Rectangle [id:dp25845825302570513] 
    \draw  [fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (265,133) -- (297.19,133) -- (297.19,161.7) -- (265,161.7) -- cycle ;
    %Shape: Rectangle [id:dp47274224679471666] 
    \draw  [fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (265,174.3) -- (297.19,174.3) -- (297.19,203) -- (265,203) -- cycle ;
    %Shape: Rectangle [id:dp5929473120919728] 
    \draw  [fill={rgb, 255:red, 126; green, 211; blue, 33 }  ,fill opacity=1 ] (325,131) -- (475,131) -- (475,201) -- (325,201) -- cycle ;
    %Shape: Rectangle [id:dp561230971836093] 
    \draw  [fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (505,131) -- (537.19,131) -- (537.19,159.7) -- (505,159.7) -- cycle ;
    %Shape: Rectangle [id:dp551714500077588] 
    \draw  [fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (505,172.3) -- (537.19,172.3) -- (537.19,201) -- (505,201) -- cycle ;
    %Shape: Rectangle [id:dp014371224119280157] 
    \draw   (565,131) -- (596.33,131) -- (596.33,159.22) -- (565,159.22) -- cycle ;
    %Shape: Arc [id:dp45728741367881365] 
    \draw  [draw opacity=0] (569.39,151.72) .. controls (570.82,147.31) and (575.03,144.13) .. (579.99,144.13) .. controls (584.9,144.13) and (589.07,147.24) .. (590.55,151.57) -- (579.99,155.06) -- cycle ; \draw   (569.39,151.72) .. controls (570.82,147.31) and (575.03,144.13) .. (579.99,144.13) .. controls (584.9,144.13) and (589.07,147.24) .. (590.55,151.57) ;  
    %Straight Lines [id:da3994764524189143] 
    \draw    (576.46,153) -- (589.1,139.61) ;
    %Shape: Rectangle [id:dp7321580418061253] 
    \draw   (565,172) -- (596.33,172) -- (596.33,200.22) -- (565,200.22) -- cycle ;
    %Shape: Arc [id:dp575518695312089] 
    \draw  [draw opacity=0] (569.39,192.72) .. controls (570.82,188.31) and (575.03,185.13) .. (579.99,185.13) .. controls (584.9,185.13) and (589.07,188.24) .. (590.55,192.57) -- (579.99,196.06) -- cycle ; \draw   (569.39,192.72) .. controls (570.82,188.31) and (575.03,185.13) .. (579.99,185.13) .. controls (584.9,185.13) and (589.07,188.24) .. (590.55,192.57) ;  
    %Straight Lines [id:da9653097238135147] 
    \draw    (576.46,194) -- (589.1,180.61) ;
    %Straight Lines [id:da054926584620969665] 
    \draw    (95,151) -- (145,151) ;
    %Straight Lines [id:da1998461114344101] 
    \draw    (95,191) -- (145,191) ;
    %Straight Lines [id:da13455039306792682] 
    \draw    (175,151) -- (205,151) ;
    %Straight Lines [id:da8941875904744676] 
    \draw    (175,191) -- (205,191) ;
    %Straight Lines [id:da16169269211888615] 
    \draw    (235,151) -- (265,151) ;
    %Straight Lines [id:da6385231938077083] 
    \draw    (235,191) -- (265,191) ;
    %Straight Lines [id:da21590920227006993] 
    \draw    (295,151) -- (325,151) ;
    %Straight Lines [id:da44624469722388915] 
    \draw    (295,191) -- (325,191) ;
    %Straight Lines [id:da9474262709127792] 
    \draw    (475,191) -- (505,191) ;
    %Straight Lines [id:da8304606265085992] 
    \draw    (475,151) -- (505,151) ;
    %Straight Lines [id:da4700710359224989] 
    \draw    (535,151) -- (565,151) ;
    %Straight Lines [id:da09738039485721028] 
    \draw    (535,191) -- (565,191) ;
    %Straight Lines [id:da7131108234298331] 
    \draw    (595,149.5) -- (625,149.5)(595,152.5) -- (625,152.5) ;
    %Straight Lines [id:da9226246067589841] 
    \draw    (595,189.5) -- (625,189.5)(595,192.5) -- (625,192.5) ;
    %Shape: Brace [id:dp5786954336630095] 
    \draw   (208.13,205) .. controls (208.15,209.67) and (210.49,211.99) .. (215.16,211.98) -- (357.81,211.53) .. controls (364.48,211.51) and (367.82,213.83) .. (367.83,218.5) .. controls (367.82,213.83) and (371.14,211.49) .. (377.81,211.47)(374.81,211.48) -- (528.16,210.99) .. controls (532.83,210.98) and (535.15,208.64) .. (535.13,203.97) ;
    %Shape: Brace [id:dp3814057437492582] 
    \draw   (470.13,127) .. controls (470.13,122.33) and (467.8,120) .. (463.13,120) -- (410.13,120) .. controls (403.46,120) and (400.13,117.67) .. (400.13,113) .. controls (400.13,117.67) and (396.8,120) .. (390.13,120)(393.13,120) -- (334.13,120) .. controls (329.46,120) and (327.13,122.33) .. (327.13,127) ;
    %Shape: Brace [id:dp5248227356988384] 
    \draw   (66.13,152) .. controls (61.46,152) and (59.13,154.33) .. (59.13,159) -- (59.13,162.16) .. controls (59.13,168.83) and (56.8,172.16) .. (52.13,172.16) .. controls (56.8,172.16) and (59.13,175.49) .. (59.13,182.16)(59.13,179.16) -- (59.13,185) .. controls (59.13,189.67) and (61.46,192) .. (66.13,192) ;
    %Straight Lines [id:da6246903517915476] 
    \draw  [dash pattern={on 0.84pt off 2.51pt}]  (75.13,168) -- (133.13,168) ;
    %Straight Lines [id:da7651260164716407] 
    \draw  [dash pattern={on 0.84pt off 2.51pt}]  (251,168) -- (305.13,168) ;
    %Straight Lines [id:da5357419850229155] 
    \draw  [dash pattern={on 0.84pt off 2.51pt}]  (504,167) -- (592.13,167) ;

    % Text Node
    \draw (151.6,139.4) node [anchor=north west][inner sep=0.75pt]    {$H$};
    % Text Node
    \draw (151.6,181.4) node [anchor=north west][inner sep=0.75pt]    {$H$};
    % Text Node
    \draw (209,155.4) node [anchor=north west][inner sep=0.75pt]    {$U_{\omega }$};
    % Text Node
    \draw (273.6,139.4) node [anchor=north west][inner sep=0.75pt]    {$H$};
    % Text Node
    \draw (273.6,181.4) node [anchor=north west][inner sep=0.75pt]    {$H$};
    % Text Node
    \draw (513.6,137.4) node [anchor=north west][inner sep=0.75pt]    {$H$};
    % Text Node
    \draw (513.6,179.4) node [anchor=north west][inner sep=0.75pt]    {$H$};
    % Text Node
    \draw (346,153.4) node [anchor=north west][inner sep=0.75pt]    {$2\ket{0^{n}}\bra{0^{n}} \ -\ I^{n}$};
    % Text Node
    \draw (68,142.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{0}$};
    % Text Node
    \draw (68,181.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{0}$};
    % Text Node
    \draw (16,162.4) node [anchor=north west][inner sep=0.75pt]    {$\ket{0^{n}}$};
    % Text Node
    \draw (316,95) node [anchor=north west][inner sep=0.75pt]   [align=left] {Grover's Diffusion Operator};
    % Text Node
    \draw (313,213) node [anchor=north west][inner sep=0.75pt]   [align=left] {Repeat $\displaystyle \approx \ \frac{\pi }{4}\sqrt{N}$ times};

\end{tikzpicture}
\end{center}

  \caption{\label{fig:grover_circuit} Quantum circuit representation of Grover's Algorithm.}
\end{figure}

\vspace{5mm}


\noindent
The diffusion operator is expressed as:
\vspace{5mm}

\begin{equation}
U_s  = 2 \ket{s}\bra{s} - 1    
\end{equation}
\vspace{5mm}

\noindent
$U_s$ is a reflection at the hyperplane orthogonal to $\ket{\perp s}$  for vectors in the plane spanned by $\ket{s}$  and $\ket{\perp s}$, in other words a reflection about $\ket{s}$. 
\vspace{5mm}

\noindent
The product of two reflection operators $U_\omega$ and $U_s$ is a rotation in the plane spanned by $\ket{\omega}$ and $\ket{s'}$ through twice the angle $\theta$.
\vspace{5mm}

\noindent
By applying $U_s$ and $U_\omega$ the initial state $\ket{s}$ is rotated close to the state $\ket{\omega}$.
\vspace{5mm}

\noindent
After repeated Grover iterations, $\ket{s}$ approaches $\ket{\omega}$, at which point an observation in the computational basis
outputs a solution to the search problem with high probability.
\vspace{5mm}

\noindent
By looking at Figure \ref{fig:grover_step_3b}, the amplitude of $\ket{\omega}$ is reflected about the average amplitude. Referring to Figure \ref{fig:grover_step_2b}, the average amplitude is lowered below the dashed line and the reflection boosts the amplitude by about three times its original value, as depicted in Figure \ref{fig:grover_step_3b}.
\vspace{5mm}

\noindent
Step 2 and Step 3 will be repeated where necessary for $T$ times until the average amplitude approaches zero so that the amplitude for $\ket{\omega} \sim 1$\cite{de_wolf_main_nodate}.
\vspace{5mm}

\noindent
By observation, the number of times $T$ is required to apply the Grover's Algorithm according to Figure \ref{fig:grover_step_3a} can be written as:
\vspace{5mm}

\noindent
\begin{equation}
\theta_T = (2T + 1)\theta
\end{equation}

Where $\theta_T \approx \frac{\pi}{2}$ and $T$ is chosen to the nearest integer. 
\pagebreak

\noindent
For an unstructured search through a sufficiently large list, $\theta$ will be small. Using the small angle approximation, $\sin\theta \approx \theta$. 
\vspace{5mm}

\noindent
Recall that $\sin\theta = \frac{1}{\sqrt{2^n}}$
\vspace{5mm}

\noindent
Hence:
\vspace{5mm}

\noindent
\begin{equation}
T \approx \frac{\pi}{4\theta} \approx \frac{\pi}{4}\sqrt{2^n}    
\end{equation}

Note that $N = 2^n$ has been used interchangeably in this literature.
\vspace{5mm}

\noindent
Consequently, it is shown that $T$ is directly proportional to the order $O(\sqrt{N})$.
\vspace{5mm}

\noindent
In terms of the amplitude of the state $\ket{s}$, it is observed to grow linearly with the number of application of $\sim T\sqrt{N}$. Therefore the amplitude and the probability are both amplified in Grover's Algorithm.
\vspace{5mm}

\noindent
For multiple search entries $M$, the number of Grover's iteration would be roughly $\sqrt{\frac{N}{M}}$.
\vspace{10mm}

\subsection{Advantages and Disadvantages}
\vspace{5mm}

\noindent
The obvious advantage of the Grover's Algorithm is the quadratic speed up over classical search algorithms. 
\vspace{5mm}

\noindent
In the previous chapter, Grover's Algorithm shows amplitude amplification on the target state $\ket{\omega}$ and this can be used to speed up a wide variety of other algorithms\cite{noauthor_grovers_nodate}. 
\vspace{5mm}

\noindent
One of the few drawbacks of the Grover's Algorithm is that it is probabilistic. However the probability error can be significantly reduced by repeating the algorithm.
\vspace{5mm}

\noindent
Due to the constraints of currently available quantum computers, Grover's Algorithm is yet to yield any  meaningful quadratic speed up compared to classical algorithms\cite{noauthor_grovers_2022}.

\pagebreak
\section{Using Grover's Algorithm to solve Sudoku}

A quantum search algorithm that can search unstructured data sets in a significantly shorter time span than classical computational methods would be extremely useful and could be applied in a variety of ways. In this section we're going to demonstrate a very simple usage of Grover's Algorithm by showcasing how it could be implemented to solve a 2x2 Binary Sudoku Board. 

\setlength{\arrayrulewidth}{0.5mm}
\setlength{\tabcolsep}{18pt}
\renewcommand{\arraystretch}{1.5}
\begin{figure}[h]
\begin{center}
    

\begin{tabular}{ |c|c|c| } 
\hline
V0 & V1  \\ 
\hline
V2 & V3 \\ 
\hline
\end{tabular}
\end{center}
\caption{2x2 Sudoku Board with variables V0,..,V3 \in \{0, 1\}}
\label{fig:Sudoku Board}
\end{figure}

\subsection{Making the Oracle}


For this Sudoku board there are three main rules to be aware of:
\begin{itemize}
    \item Each box can only be filled with a single number, either 0 or 1
    \item No column can contain two of the same number
    \item No row can contain two of the same number
\end{itemize}

Given that we are only dealing with a maximum of two number options (0 and 1) we can represent each variable VX (where X $\in \{0, 1, 2, 3\}$) as a singular qubit which gives us 4 input qubits, this satisfies our first rule. 
Rules 2 and 3 state that no adjacent variables can be equal to each other, the way this is done is using an XOR gate over two qubits which represent adjacent variables. For example, V0 (XOR) V1 returns $\ket{0}$ when V0 = V1 but returns $\ket{1}$ when $V0 \neq V1$. With 4 sets of comparisons to make, there is going to be a set of 4 XOR gates with the outputs for each XOR gate being stored in a separate qubit (which we'll refer to as condition qubits). This means that in total we have 8 qubits but to fully complete the Oracle gate we're going to need 1 more. After each comparison is stored in the 4 condition qubits we need to check that every condition qubit is in the state $\ket{1}$ (which is akin to saying every rule in the Sudoku board is obeyed); to do this a customised Control-Not gate is applied across each condition qubit (where the condition qubits are the control and the target/ return value is stored in the final 9th qubit which we'll refer to as the output qubit). \\
The final step in creating the Oracle gate is resetting every value in the 4 condition qubits by reapplying every XOR gate.  

As shown in \ref
\begin{equation}
\begin{cases}
      U_{\omega}\ket{x} = -\ket{x}  & \text{for} \ x = \omega, \ f(x) =1 \\
       U_{\omega}\ket{x} = \ket{x}  & \text{for} \ x \neq \omega, \ f(x) = 0 \\
\end{cases}  
\end{equation}



\pagebreak

\section{Phase Estimation}
\vspace{5mm}

\subsection{Introduction}
Suppose you have a unitary operator $U$ and its eigenvector $\ket{u}$ with eigenvalue $e^{2\pi i \phi}$, with $\phi$ unknown. By performing phase estimation, we can estimate $\phi$ (exact if the decimal expansion of $\phi$ is finite), up to required precision $n$. Phase estimation is needed for the algorithm of order-finding and it's extension, Shor's factoring algorithm. The figure below illustrate this process.

\vspace{5mm}
\begin{figure}[h]
    \centering
    

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
\path (0,195); %set diagram left start at 0, and has height of 300

%Shape: Rectangle [id:dp5239908419271088] 
\draw   (249,94) -- (340.33,94) -- (340.33,154) -- (249,154) -- cycle ;
%Shape: Rectangle [id:dp798673162776731] 
\draw   (94.33,91) -- (203.33,91) -- (203.33,165) -- (94.33,165) -- cycle ;
%Straight Lines [id:da0439097804330606] 
\draw    (211,124) -- (241.33,124) ;
\draw [shift={(243.33,124)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da053999006588390186] 
\draw    (351,123) -- (377.33,123) ;
\draw [shift={(379.33,123)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Rectangle [id:dp5103744878863842] 
\draw   (389,104) -- (450.33,104) -- (450.33,144) -- (389,144) -- cycle ;
%Shape: Rectangle [id:dp6849328641759378] 
\draw   (74.33,46) -- (468.33,46) -- (468.33,196) -- (74.33,196) -- cycle ;

% Text Node
\draw (270,112) node [anchor=north west][inner sep=0.75pt]  [font=\LARGE] [align=left] {QPE};
% Text Node
\draw (127,98) node [anchor=north west][inner sep=0.75pt]   [align=left][font=\LARGE] {$\displaystyle U\ ( \phi )$};
% Text Node
\draw (112,63) node [anchor=north west][inner sep=1pt]   [align=left]{$\displaystyle U\ket{u} =e^{2\pi i\phi }$};
% Text Node
\draw (136,134) node [anchor=north west][inner sep=0.75pt] [font=\LARGE]  [align=left] {$\displaystyle \ket{u}$};
% Text Node
\draw (413,113) node [anchor=north west][inner sep=0.75pt][font=\LARGE]   [align=left] {$\displaystyle \phi $};


\end{tikzpicture}

\caption{Phase Estimation (abbreviated as QPE).}
\end{figure}

\subsection{Quantum Fourier Transform}
\vspace{5mm}

To implement the phase estimation algorithm, the key ingredient is the quantum Fourier transform. Quantum Fourier transform is analogous to the classical discrete Fourier transform, where the basis of a vector is changed into another basis that is useful for computation or analysis. The effect of quantum Fourier transform on an arbitrary state vector can be summarised as below \cite{nielsen_quantum_2010}:
\begin{equation}
    \ket{v} = \frac{1}{\sqrt{N}} \sum_{i=0}^{N-1}{x_i \ket{i}} \xRightarrow{QFT} \ket{\Tilde{v}} = \frac{1}{\sqrt{N}}\sum_{j=0}^{N-1} y_j \ket{j}
\end{equation} 

\noindent
Note that only the amplitudes of the eigenstates are affected by this transformation. Similar to Fourier transform which decomposes functions depending on space or time into functions depending on spatial frequency or temporal frequency, QFT maps the computational basis states between the $\hat{\textbf{z}}$-basis states to the $\hat{\textbf{x}}$-basis states.
\vspace{5mm}

\noindent
The $\hat{\textbf{x}}$-basis states are defined as:
\vspace{5mm}

\begin{equation}
\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \ \text{and} \ \ket{-} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})   
\end{equation}

\pagebreak

\noindent
For multi-qubit states in the computational basis have corresponding states in the Fourier basis. The QFT is the function that transforms between these bases\cite{noauthor_quantum_nodate-1}:
\vspace{5mm}

\begin{equation}
\ket{\text{State in computational basis}} \rightarrow{\text{QFT}} \ket{\text{State in Fourier basis}}  
\end{equation}
\vspace{5mm}

\qquad $\text{QFT}\ket{x} = \ket{\tilde{x}}$
\vspace{5mm}

For a $n$ qubit states, the QFT has the effect of \cite{nielsen_quantum_2010}:
\vspace{5mm}
\begin{equation}
\text{QFT}_N\ket{x} = \frac{1}{\sqrt{N}} \sum\limits_{y=0}^{N-1}e^{2i\pi\frac{xy}{2^n}}\ket{y} \ , \ \text{for} \ N = 2^n    
\end{equation}

\vspace{5mm}

\begin{equation}
=  \frac{1}{\sqrt{N}} \sum\limits_{y=0}^{N-1}e^{2i\pi x(\sum_{k=1}^{n}\frac{y_k}{2^k})}\ket{y...y_n} 
\end{equation}
\vspace{5mm}

Rewriting $y$ in binary fraction $y= y_1 ... y_n, \ \frac{y}{2^n} = \sum\limits_{k=1}^{n}\frac{y_k}{2^k}$   
\vspace{5mm}

\begin{equation}
= \frac{1}{\sqrt{N}} \sum\limits_{y=0}^{N-1}\prod\limits_{k=1}^{n}e^{2i\pi x\frac{y_k}{2^k}}\ket{y...y_n}    
\end{equation}
\vspace{5mm}

\noindent
After expanding the exponential of a sum to a product of exponentials.
\vspace{5mm}

\begin{equation}
= \frac{1}{\sqrt{N}}\bigotimes\limits_{k=1}^{n}(\ket{0} + e^{\frac{2i\pi x}{2^k}}\ket{1})  
\end{equation}
\vspace{5mm}

\noindent
After rearranging the sum and products, and expanding $\sum\limits_{y=0}^{N-1} = \sum\limits_{y_1=0}^{1}\sum\limits_{y_2=0}^{1}...\sum\limits_{y_0=0}^{1} $
\vspace{5mm}

\begin{equation}
= \frac{1}{\sqrt{N}}(\ket{0} + e^{\frac{2i\pi x}{2}}\ket{1}) \otimes (\ket{0} + e^{\frac{2i\pi x}{2^2}}\ket{1}) \otimes ... \otimes(\ket{0} + e^{\frac{2i\pi x}{2^{n-1}}}\ket{1}) \otimes (\ket{0} + e^{\frac{2i\pi x}{2^n}}\ket{1})    
\end{equation}
\pagebreak

The circuit to implement QFT for a n-qubit state is shown below
\vspace{5mm}

\noindent


\begin{figure}[h]
    \centering


\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Straight Lines [id:da3967690953518057] 
\draw    (380,179) -- (659.75,179) ;
%Straight Lines [id:da9878029252695806] 
\draw    (469.83,168.25) -- (469.69,139.19) -- (469.69,59.8) ;
%Straight Lines [id:da8582177199826221] 
\draw    (416.83,168) -- (416.83,99.2) ;
%Straight Lines [id:da3196026977221085] 
\draw    (196.83,220) -- (660.75,220) ;
%Straight Lines [id:da07684763739566802] 
\draw    (50.88,221.33) -- (170.83,220) ;
%Shape: Rectangle [id:dp7166077461715553] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (80.83,203) -- (111.86,203) -- (111.86,234) -- (80.83,234) -- cycle ;

%Shape: Rectangle [id:dp758880806339667] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (120.83,203) -- (163.83,203) -- (163.83,234) -- (120.83,234) -- cycle ;

%Straight Lines [id:da9072316210568465] 
\draw    (141.83,203) -- (141.83,178.06) ;
%Shape: Rectangle [id:dp887638468970721] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (202.83,202) -- (246.83,202) -- (246.83,233) -- (202.83,233) -- cycle ;
%Straight Lines [id:da4039836031001398] 
\draw    (222.83,202) -- (222.33,99.5) ;
%Shape: Ellipse [id:dp5470892460263189] 
\draw  [fill={rgb, 255:red, 2; green, 2; blue, 2 }  ,fill opacity=1 ] (222,99.06) .. controls (222,99.92) and (222.45,100.62) .. (223,100.62) .. controls (223.55,100.62) and (224,99.92) .. (224,99.06) .. controls (224,98.2) and (223.55,97.5) .. (223,97.5) .. controls (222.45,97.5) and (222,98.2) .. (222,99.06) -- cycle ;

%Shape: Rectangle [id:dp7396779533097696] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (256.83,202) -- (300.83,202) -- (300.83,233) -- (256.83,233) -- cycle ;
%Straight Lines [id:da9953579128910641] 
\draw    (277.83,202) -- (277.83,58.33) ;
%Straight Lines [id:da304584348508544] 
\draw    (53.18,178.5) -- (217.35,178.5) -- (345.75,178.5) ;
%Straight Lines [id:da19441753788178195] 
\draw    (54.95,99.06) -- (222,99.06) -- (656.95,99.06) ;
%Straight Lines [id:da5686077293635534] 
\draw    (53.83,59) -- (656.83,58) ;
%Shape: Ellipse [id:dp6678818886024199] 
\draw  [fill={rgb, 255:red, 2; green, 2; blue, 2 }  ,fill opacity=1 ] (141,179.06) .. controls (141,179.92) and (141.45,180.62) .. (142,180.62) .. controls (142.55,180.62) and (143,179.92) .. (143,179.06) .. controls (143,178.2) and (142.55,177.5) .. (142,177.5) .. controls (141.45,177.5) and (141,178.2) .. (141,179.06) -- cycle ;
%Shape: Ellipse [id:dp7348740438597149] 
\draw  [fill={rgb, 255:red, 2; green, 2; blue, 2 }  ,fill opacity=1 ] (278,59.06) .. controls (278,59.92) and (278.45,60.62) .. (279,60.62) .. controls (279.55,60.62) and (280,59.92) .. (280,59.06) .. controls (280,58.2) and (279.55,57.5) .. (279,57.5) .. controls (278.45,57.5) and (278,58.2) .. (278,59.06) -- cycle ;
%Shape: Rectangle [id:dp6251794280116343] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (307,163) -- (338.03,163) -- (338.03,194) -- (307,194) -- cycle ;

%Straight Lines [id:da48501832285910107] 
\draw    (617,59) -- (618,220) ;
%Straight Lines [id:da3619533645667148] 
\draw    (612,53) -- (622,63) ;
%Straight Lines [id:da1136318355264534] 
\draw    (622,53) -- (612,63) ;

%Straight Lines [id:da8858890162256563] 
\draw    (613,215) -- (623,225) ;
%Straight Lines [id:da6829327205842372] 
\draw    (623,215) -- (613,225) ;


%Straight Lines [id:da8840707107750161] 
\draw    (644,100) -- (644,177) ;
%Straight Lines [id:da454844448542837] 
\draw    (639,174) -- (649,184) ;
%Straight Lines [id:da7602550013601753] 
\draw    (649,174) -- (639,184) ;

%Straight Lines [id:da9458589943076327] 
\draw    (639,95) -- (649,105) ;
%Straight Lines [id:da01796925917370651] 
\draw    (649,95) -- (639,105) ;


%Shape: Rectangle [id:dp4590967975075022] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (449.83,164.25) -- (493.83,164.25) -- (493.83,196) -- (449.83,196) -- cycle ;
%Shape: Ellipse [id:dp4611610254403936] 
\draw  [fill={rgb, 255:red, 2; green, 2; blue, 2 }  ,fill opacity=1 ] (470,59.8) .. controls (470,60.68) and (470.45,61.39) .. (471,61.39) .. controls (471.55,61.39) and (472,60.68) .. (472,59.8) .. controls (472,58.91) and (471.55,58.2) .. (471,58.2) .. controls (470.45,58.2) and (470,58.91) .. (470,59.8) -- cycle ;
%Shape: Rectangle [id:dp47171557119826113] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (396.83,165) -- (440.83,165) -- (440.83,196) -- (396.83,196) -- cycle ;
%Shape: Ellipse [id:dp39067266570391845] 
\draw  [fill={rgb, 255:red, 2; green, 2; blue, 2 }  ,fill opacity=1 ] (416.83,98.64) .. controls (416.83,99.5) and (417.28,100.2) .. (417.83,100.2) .. controls (418.39,100.2) and (418.83,99.5) .. (418.83,98.64) .. controls (418.83,97.78) and (418.39,97.08) .. (417.83,97.08) .. controls (417.28,97.08) and (416.83,97.78) .. (416.83,98.64) -- cycle ;
%Shape: Rectangle [id:dp7816137489930797] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (491.97,85) -- (523,85) -- (523,116) -- (491.97,116) -- cycle ;

%Shape: Rectangle [id:dp8241920393207232] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (528,83) -- (568,83) -- (568,114) -- (528,114) -- cycle ;

%Straight Lines [id:da24945250453126844] 
\draw    (543.5,84) -- (543.5,60) ;
%Shape: Circle [id:dp18896475231461685] 
\draw  [fill={rgb, 255:red, 2; green, 2; blue, 2 }  ,fill opacity=1 ] (542,60) .. controls (542,60.83) and (542.67,61.5) .. (543.5,61.5) .. controls (544.33,61.5) and (545,60.83) .. (545,60) .. controls (545,59.17) and (544.33,58.5) .. (543.5,58.5) .. controls (542.67,58.5) and (542,59.17) .. (542,60) -- cycle ;


%Shape: Rectangle [id:dp7852662448600767] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (568,44) -- (599.03,44) -- (599.03,75) -- (568,75) -- cycle ;


% Text Node
\draw (1,47) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{x_{1}}$};
% Text Node
\draw (1,87) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{x_{2}}$};
% Text Node
\draw (1,166) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{x_{n-1}}$};
% Text Node
\draw (1,207) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{x_{n}}$};
% Text Node
\draw (5,11) node [anchor=north west][inner sep=0.75pt]   [align=left] {Input: $\displaystyle \ket{x_{n} x_{n-1} \cdots x_{2} x_{1}} =\ket{x_{n}} \otimes \ket{x_{n-1}} \otimes \cdots \otimes \ket{x_{2}} \otimes \ket{x_{1}}$};
% Text Node
\draw (170.83,206) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \dotsc $};
% Text Node
\draw (268.83,208) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle R_{n}$};
% Text Node
\draw (133.19,210) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle R_{2}$};
% Text Node
\draw (89.83,209.7) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle H$};
% Text Node
\draw (316,169.7) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle H$};
% Text Node
\draw (208.23,209) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle R_{n-1}$};
% Text Node
\draw (402.23,171) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle R_{n-2}$};
% Text Node
\draw (348.83,165) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \dotsc $};
% Text Node
\draw (455.23,171.63) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle R_{n-1}$};
% Text Node
\draw (500.97,91.7) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle H$};
% Text Node
\draw (538.8,90) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle R_{2}$};
% Text Node
\draw (577,50.7) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle H$};


\end{tikzpicture}

\caption{The QFT Circuit}
\end{figure}
\vspace{5mm}

where $H$ is the Hadamard gate, \(R_n = 
\begin{bmatrix}
    1 & 0 \\
    0 & e^{2\pi i/2^k}
\end{bmatrix} \)
, and the \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=0.5,xscale=0.5]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Straight Lines [id:da5239484844882938] 
\draw    (85,16) -- (85,47) ;
%Straight Lines [id:da8400020556735358] 
\draw    (80,40) -- (90,50) ;
%Straight Lines [id:da24481923694858] 
\draw    (90,40) -- (80,50) ;

%Straight Lines [id:da0676093949143659] 
\draw    (80,10) -- (90,20) ;
%Straight Lines [id:da9539947353268269] 
\draw    (90,10) -- (80,20) ;
\end{tikzpicture} is a swap gate, which swaps the qubit i with the n-i qubit. However, the phase estimation algorithm requires the inverse QFT, which is easy to construct by flipping the circuit horizontally, and conjugate the phases in the $R_k$ gate.
\pagebreak
\subsection{The Algorithm}
The phase estimation procedure uses two registers, with the first register containing $m$ qubits (all in the state $\ket{0}$) and the second register is in the state $\ket{u}$, and contains as many qubits as required for $\ket{u}$. The number of qubits $m$ for first register is dependent on the precision of the phase required, which will be discussed in the next section. The algorithm can be summarized below:
\begin{enumerate}
    \item Hadamard gates are applied to all qubits in first register.
    \item Control-U gates raised to successive powers of two is applied consecutively to the second register, with the controls covering the first qubit to the last qubit in the first register.
    \item The inverse QFT operation is then applied on the first register to obtain a number, which needs further to be further divided by $2^m$ to recover the estimation of the phase.
\end{enumerate}
The circuit below sums up the whole procedure.
\vspace{5mm}


    
\begin{figure}[h]

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-0.95,xscale=0.95]
%uncomment if require: \path (0,255); %set diagram left start at 0, and has height of 255

%Straight Lines [id:da9194835056551176] 
\draw    (120.56,38.44) -- (304.21,38.44) ;
%Straight Lines [id:da6985548639030699] 
\draw    (120.56,74.27) -- (304.21,74.27) ;
%Straight Lines [id:da7116263330867054] 
\draw    (120.56,110.11) -- (304.21,110.11) ;
%Straight Lines [id:da8626589126730531] 
\draw    (120.56,163.86) -- (304.21,163.86) ;
%Straight Lines [id:da19695588367886063] 
\draw    (120.56,208.65) -- (304.21,208.65) ;
%Straight Lines [id:da10938435456147] 
\draw    (120.56,217.61) -- (304.21,217.61) ;
%Straight Lines [id:da4912942246519334] 
\draw    (120.56,226.57) -- (304.21,226.57) ;
%Straight Lines [id:da12940095959327003] 
\draw    (120.56,235.53) -- (304.21,235.53) ;
%Shape: Rectangle [id:dp15884195779468213] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (132.04,25) -- (158.54,25) -- (158.54,51.88) -- (132.04,51.88) -- cycle ;

%Shape: Rectangle [id:dp23256435967097955] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (132.93,62.63) -- (159.42,62.63) -- (159.42,89.5) -- (132.93,89.5) -- cycle ;

%Shape: Rectangle [id:dp37562370103024234] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (132.93,99.36) -- (159.42,99.36) -- (159.42,126.23) -- (132.93,126.23) -- cycle ;

%Shape: Rectangle [id:dp03136015448302287] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (132.93,149.53) -- (159.42,149.53) -- (159.42,176.4) -- (132.93,176.4) -- cycle ;

%Shape: Rectangle [id:dp03155077547529872] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (169.1,204.17) -- (200.01,204.17) -- (200.01,240.01) -- (169.1,240.01) -- cycle ;

%Shape: Rectangle [id:dp9729186752169825] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (209.72,205.07) -- (240.63,205.07) -- (240.63,240.9) -- (209.72,240.9) -- cycle ;
%Shape: Rectangle [id:dp19964985396092239] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (251.23,205.97) -- (282.14,205.97) -- (282.14,241.8) -- (251.23,241.8) -- cycle ;
%Straight Lines [id:da7109063051521263] 
\draw    (351.93,38.44) -- (541.76,38.44) ;
%Straight Lines [id:da1930170699837772] 
\draw    (351.93,74.27) -- (541.76,74.27) ;
%Straight Lines [id:da7712890300467412] 
\draw    (351.93,110.11) -- (541.76,110.11) ;
%Straight Lines [id:da00469730483476738] 
\draw    (351.93,163.86) -- (541.76,163.86) ;
%Straight Lines [id:da9060427595505647] 
\draw    (351.93,208.65) -- (541.76,208.65) ;
%Straight Lines [id:da24660499214292575] 
\draw    (351.93,217.61) -- (541.76,217.61) ;
%Straight Lines [id:da8073093108188725] 
\draw    (351.93,226.57) -- (541.76,226.57) ;
%Straight Lines [id:da9156311780855882] 
\draw    (351.93,235.53) -- (541.76,235.53) ;
%Shape: Rectangle [id:dp5274524103344703] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (362.5,203.28) -- (406.65,203.28) -- (406.65,239.11) -- (362.5,239.11) -- cycle ;
%Straight Lines [id:da03444841972411539] 
\draw    (185,39.15) -- (184.14,205.07) ;
%Straight Lines [id:da009404546254211943] 
\draw    (226.5,74.09) -- (225.65,205.07) ;
%Straight Lines [id:da374044199582911] 
\draw    (268.01,110.82) -- (267.15,205.97) ;
%Straight Lines [id:da6555871247561469] 
\draw    (384.57,163.68) -- (384.6,203.28) ;
%Shape: Ellipse [id:dp31242914795993315] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (183.26,37.98) .. controls (183.26,36.75) and (184.24,35.75) .. (185.45,35.75) .. controls (186.67,35.75) and (187.65,36.75) .. (187.65,37.98) .. controls (187.65,39.2) and (186.67,40.2) .. (185.45,40.2) .. controls (184.24,40.2) and (183.26,39.2) .. (183.26,37.98) -- cycle ;
%Shape: Ellipse [id:dp8473767958403672] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (224.77,73.81) .. controls (224.77,72.58) and (225.75,71.59) .. (226.96,71.59) .. controls (228.17,71.59) and (229.15,72.58) .. (229.15,73.81) .. controls (229.15,75.04) and (228.17,76.03) .. (226.96,76.03) .. controls (225.75,76.03) and (224.77,75.04) .. (224.77,73.81) -- cycle ;
%Shape: Ellipse [id:dp8148369515275169] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (266.27,108.75) .. controls (266.27,107.52) and (267.25,106.52) .. (268.46,106.52) .. controls (269.67,106.52) and (270.66,107.52) .. (270.66,108.75) .. controls (270.66,109.98) and (269.67,110.97) .. (268.46,110.97) .. controls (267.25,110.97) and (266.27,109.98) .. (266.27,108.75) -- cycle ;
%Shape: Ellipse [id:dp35408407729589786] 
\draw  [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ,fill opacity=1 ] (381.95,164.29) .. controls (381.95,163.06) and (382.94,162.07) .. (384.15,162.07) .. controls (385.36,162.07) and (386.34,163.06) .. (386.34,164.29) .. controls (386.34,165.52) and (385.36,166.52) .. (384.15,166.52) .. controls (382.94,166.52) and (381.95,165.52) .. (381.95,164.29) -- cycle ;
%Shape: Rectangle [id:dp08709255028482066] 
\draw  [fill={rgb, 255:red, 255; green, 255; blue, 255 }  ,fill opacity=1 ] (427.87,27.69) -- (517.92,27.69) -- (517.92,178.01) -- (427.87,178.01) -- cycle ;
%Shape: Rectangle [id:dp5816935501240186] 
\draw   (547.09,25.72) -- (577.08,25.72) -- (577.08,50.35) -- (547.09,50.35) -- cycle ;
%Shape: Arc [id:dp9020959249791546] 
\draw  [draw opacity=0] (550.64,41.69) .. controls (551.36,37.36) and (556.49,34.36) .. (562.41,34.91) .. controls (567.93,35.44) and (572.26,38.89) .. (572.77,42.92) -- (561.69,43.23) -- cycle ; \draw   (550.64,41.69) .. controls (551.36,37.36) and (556.49,34.36) .. (562.41,34.91) .. controls (567.93,35.44) and (572.26,38.89) .. (572.77,42.92) ;  
%Straight Lines [id:da9091015813949274] 
\draw    (560.97,45.47) -- (565.77,29.87) ;
\draw [shift={(566.36,27.96)}, rotate = 107.1] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (4.37,-1.32) .. controls (2.78,-0.56) and (1.32,-0.12) .. (0,0) .. controls (1.32,0.12) and (2.78,0.56) .. (4.37,1.32)   ;

%Shape: Rectangle [id:dp715253231601205] 
\draw   (547.09,61.55) -- (577.08,61.55) -- (577.08,86.19) -- (547.09,86.19) -- cycle ;
%Shape: Arc [id:dp37902783293727893] 
\draw  [draw opacity=0] (550.64,77.53) .. controls (551.36,73.19) and (556.49,70.19) .. (562.41,70.75) .. controls (567.93,71.27) and (572.26,74.72) .. (572.77,78.76) -- (561.69,79.06) -- cycle ; \draw   (550.64,77.53) .. controls (551.36,73.19) and (556.49,70.19) .. (562.41,70.75) .. controls (567.93,71.27) and (572.26,74.72) .. (572.77,78.76) ;  
%Straight Lines [id:da6659199046761912] 
\draw    (560.97,81.3) -- (565.77,65.7) ;
\draw [shift={(566.36,63.79)}, rotate = 107.1] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (4.37,-1.32) .. controls (2.78,-0.56) and (1.32,-0.12) .. (0,0) .. controls (1.32,0.12) and (2.78,0.56) .. (4.37,1.32)   ;

%Shape: Rectangle [id:dp5396491521682578] 
\draw   (547.09,98.28) -- (577.08,98.28) -- (577.08,122.92) -- (547.09,122.92) -- cycle ;
%Shape: Arc [id:dp19388376844570432] 
\draw  [draw opacity=0] (550.64,114.26) .. controls (551.36,109.92) and (556.49,106.92) .. (562.41,107.48) .. controls (567.93,108) and (572.26,111.45) .. (572.77,115.49) -- (561.69,115.79) -- cycle ; \draw   (550.64,114.26) .. controls (551.36,109.92) and (556.49,106.92) .. (562.41,107.48) .. controls (567.93,108) and (572.26,111.45) .. (572.77,115.49) ;  
%Straight Lines [id:da8381741578506972] 
\draw    (560.97,118.03) -- (565.77,102.43) ;
\draw [shift={(566.36,100.52)}, rotate = 107.1] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (4.37,-1.32) .. controls (2.78,-0.56) and (1.32,-0.12) .. (0,0) .. controls (1.32,0.12) and (2.78,0.56) .. (4.37,1.32)   ;

%Shape: Rectangle [id:dp04173030496706942] 
\draw   (547.97,150.24) -- (577.97,150.24) -- (577.97,174.88) -- (547.97,174.88) -- cycle ;
%Shape: Arc [id:dp5223668572095267] 
\draw  [draw opacity=0] (551.52,166.22) .. controls (552.24,161.88) and (557.38,158.88) .. (563.29,159.44) .. controls (568.82,159.96) and (573.14,163.41) .. (573.65,167.45) -- (562.57,167.76) -- cycle ; \draw   (551.52,166.22) .. controls (552.24,161.88) and (557.38,158.88) .. (563.29,159.44) .. controls (568.82,159.96) and (573.14,163.41) .. (573.65,167.45) ;  
%Straight Lines [id:da3372443183558913] 
\draw    (561.86,169.99) -- (566.66,154.39) ;
\draw [shift={(567.25,152.48)}, rotate = 107.1] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (4.37,-1.32) .. controls (2.78,-0.56) and (1.32,-0.12) .. (0,0) .. controls (1.32,0.12) and (2.78,0.56) .. (4.37,1.32)   ;

%Shape: Brace [id:dp8116415853490204] 
\draw   (92.27,38.55) .. controls (87.6,38.55) and (85.27,40.88) .. (85.27,45.55) -- (85.27,91.88) .. controls (85.27,98.55) and (82.94,101.88) .. (78.27,101.88) .. controls (82.94,101.88) and (85.27,105.21) .. (85.27,111.88)(85.27,108.88) -- (85.27,158.21) .. controls (85.27,162.88) and (87.6,165.21) .. (92.27,165.21) ;
%Shape: Brace [id:dp33774914340487494] 
\draw   (585.97,165.8) .. controls (590.64,165.8) and (592.97,163.47) .. (592.97,158.8) -- (592.97,112.8) .. controls (592.97,106.13) and (595.3,102.8) .. (599.97,102.8) .. controls (595.3,102.8) and (592.97,99.47) .. (592.97,92.8)(592.97,95.8) -- (592.97,46.8) .. controls (592.97,42.13) and (590.64,39.8) .. (585.97,39.8) ;

% Text Node
\draw (93.49,30.39) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{0}$};
% Text Node
\draw (93.49,66.22) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{0}$};
% Text Node
\draw (93.49,101.16) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{0}$};
% Text Node
\draw (91.73,154.91) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{0}$};
% Text Node
\draw (92.55,214.04) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{u}$};
% Text Node
\draw (137.35,29.49) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle H$};
% Text Node
\draw (138.23,67.12) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle H$};
% Text Node
\draw (138.23,103.85) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle H$};
% Text Node
\draw (138.23,154.02) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle H$};
% Text Node
\draw (169.09,210.09) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle U{^{2}}^{0}$};
% Text Node
\draw (361.54,209.2) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle U{^{2}}^{m-1}$};
% Text Node
\draw (209.71,210.99) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle U{^{2}}^{1}$};
% Text Node
\draw (251.21,211.88) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle U{^{2}}^{2}$};
% Text Node
\draw (543.8,213.14) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{u}$};
% Text Node
\draw (453.68,92.99) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle QFT^{\dagger }$};
% Text Node
\draw (361.59,131.62) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \vdots $};
% Text Node
\draw (286.53,131.62) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \vdots $};
% Text Node
\draw (314.91,33.07) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \cdots $};
% Text Node
\draw (314.91,71.6) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \cdots $};
% Text Node
\draw (314.91,106.53) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \cdots $};
% Text Node
\draw (313.14,214.04) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \cdots $};
% Text Node
\draw (1,90) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {First register\\ \ \ $m$ qubits};
% Text Node
\draw (13,203) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] {Second \\register};
% Text Node
\draw (611,91) node [anchor=north west][inner sep=0.75pt]   [align=left] {$\displaystyle \ket{\varphi }$};
% Text Node
\draw (594,124) node [anchor=north west][inner sep=0.75pt]  [font=\small] [align=left] { $\displaystyle \phi \ =\ \frac{\varphi }{2^{m}}$};
\end{tikzpicture}
\caption{The Phase Estimation Circuit}
\end{figure}
\vspace{10mm} 

\noindent 
How do we choose $m$ for the first register? Suppose the phase $\phi$ has $t$ decimal places, and we wish to estimate only until $n$ decimal places, with success probability $1-\varepsilon$, we need to choose $m$ such that \cite{nielsen_quantum_2010}
\vspace{5mm}

\begin{equation}
m=n+\bigg[log_2\bigg(2+\frac{1}{2\varepsilon}\bigg)\bigg]    
\end{equation}

For example, $\phi = \frac{1}{3} = 0.3333...$ and we wish to estimate it to 3 decimal places with probability 0.70. Thus, $n=3$ and $\varepsilon = 0.3$, which gives 
\vspace{5mm}

\begin{equation}
m = 3 + \bigg[log_2\bigg(2+\frac{1}{0.6}\bigg)\bigg]=4.5 \rightarrow m=5    
\end{equation} since $m$ is an integer.

\pagebreak

\section{Organisation \& Methodology}

The group comprised 6 members, and organised the workflow and job allocation required to complete the project by following a hybrid \textit{Agile}\cite{noauthor_manifesto_nodate} framework, by structuring ourselves as a "self-organising team", the hallmark of the \textit{Agile} framework.

This was achieved by splitting the workload into weekly \textit{sprints} and by holding an in person \textit{sprint meeting} every Friday at 2pm in JCMB 2901, which we had booked out for the duration of the project.

The \textit{sprint meetings} were simply in person meetings where everyone gave the group a breakdown of the work that they completed in the prior week in a round-robin fashion.

Once the entire team was updated on the progress in the prior week, we discussed what needed to be done in the following week, and also kept the overall goals of the project in mind during each meeting.

When the work required for the week was agreed on, we then allocated team members to tasks if a certain team member was most suited to that task, and was willing to take on the workload. For tasks that were not pre-allocated, we allocated the work using a simple online allocation tool.

Generally each sprint, the workload for the week was split into three sections, and the team was allocated in pairs to tackle their assignment for the week.

As examples of weekly tasks, during the initial weeks of the project, groups were assigned to implementing code for the matrix classes, and a separate group for a tensor product implementation. Later on as the code base became more mature, groups were allocated to expanding the test coverage on existing code (see the section \ref{testing} for details).

During each weekly sprint the sub-teams would organise among themselves to meet in person or virtually to complete the work they were assigned, making sure that all progress was committed to GitHub in order to keep the entire team up to speed on code development.

This included the report and code documentation in a separate \textit{docs} folder within the GitHub repository.

When an in person meeting couldn't be arranged a virtual meeting was organised over Zoom instead, as close as possible to the original planned time. This was to ensure that there were minimal compromises in group planning and organisation, with progress being still reported and tasks still being assigned for the next weekly cycle on-time.

This loop of weekly meetings, allocating tasks, and working in sub-teams continued until the project completed. 

By breaking up the large task into smaller more obtainable weekly tasks, we completed the project in a more efficient manner that minimised stress on the group, these meetings boosted morale and increased productivity by putting the work of all other group members on display.

\subsection{\label{git}Git \& Github}

We organised and collaborated on our codebase using the Git\cite{noauthor_git_nodate} Version Control System (VCS) software, which is the standard VCS used in the software development world.
Our code was hosted on a public Github\cite{noauthor_build_nodate} repository, at \url{https://github.com/Tiernan8r/quantum_computing_project} and is freely available open source code under the Apache 2.0 License\cite{noauthor_apache_nodate}.
Using a git repository hosted on Github had many advantages. The \textit{master} branch on the repository represented the state of the codebase for all group members, allowining us to keep the code organised in one place, rather than having different versions of the code on each group members computers.
The development cycle of branching off from the master branch, implementing the relevant code changes for your weekly task, and then opening a \textit{pull request} (PR) on github to merge the changes into the \textit{master} branch. 
When a PR was created on github, each team-member would be automatically notified by email that a group member was requesting changes to the master branch.
By taking advantage of some of github's powerful collaboration and administration tools, we set requirements on PRs that each change requested had to be approved by another group member before it could be merged to the \textit{master} branch.
We also took advantage of the \textit{Github Actions} service to automatically run testing, linting and documentation routines on the PRs. 
This ensured that PRs were not introducing bugs or vulnerabilities into the codebase (see section \ref{testing}), and enforced the \textit{pep8}\cite{noauthor_pep_nodate} pythonic style guide. 
We used the \textit{Sphinx}\cite{noauthor_overview_nodate} documentation tool to automatically compile our code \textit{docstrings} into documentation hosted on github at \url{https://tiernan8r.github.io/quantum_computing_project/} which allowed us to quickly and painlessly look up code functionality without having to dive into the codebase.

\subsection{\label{testing}Testing and Debugging}

\begin{figure}
\begin{verbatim}
---------- coverage: platform linux, python 3.8.10-final-0 -----------
Name                                                  Stmts   Miss Branch BrPart  Cover
---------------------------------------------------------------------------------------
qcp/__init__.py                                           1      0      0      0   100%
qcp/algorithms/__init__.py                                4      0      0      0   100%
qcp/algorithms/abstract_algorithm.py                     32      2     10      2    90%
qcp/algorithms/grovers_algorithm.py                      51      5     20      0    90%
qcp/algorithms/phase_estimation.py                       86     64     24      0    22%
qcp/algorithms/phase_estimation_unitary_matrices.py      32     18     16      0    33%
qcp/algorithms/sudoku.py                                 44     32     10      0    26%
qcp/cli/__init__.py                                       1      0      0      0   100%
qcp/cli/constants.py                                     20      0      0      0   100%
qcp/cli/interpret.py                                     79     44     26      5    38%
qcp/cli/options.py                                       25     12     16      0    41%
qcp/cli/parser.py                                        57     13     22      4    78%
qcp/cli/progress_bar.py                                  13      8      0      0    38%
qcp/cli/usage.py                                          7      0      0      0   100%
qcp/constants.py                                         11      0      0      0   100%
qcp/gates.py                                            120      0     36      0   100%
qcp/main.py                                              48     30      6      2    37%
qcp/matrices/__init__.py                                  6      0      0      0   100%
qcp/matrices/dense_matrix.py                            102     13     52      1    86%
qcp/matrices/matrix.py                                   49     16      2      0    69%
qcp/matrices/sparse_matrix.py                           218     30    140     11    84%
qcp/matrices/types.py                                     6      0      0      0   100%
qcp/register.py                                          17      1      8      1    92%
qcp/tensor_product.py                                    44      1     24      1    94%
---------------------------------------------------------------------------------------
TOTAL                                                  1073    289    412     27    72%
Coverage XML written to file coverage/python/coverage.xml

\end{verbatim}
\caption{\label{tox-coverage} Example output of \textit{tox} coverage, with the \textbf{qcp/gui/} code coverage removed for the sake of brevity}
\end{figure}

Testing on our codebase was implemented using the \textit{pytest}\cite{noauthor_pytest_nodate} Python testing utility, and the testing was automated using the \textit{tox}\cite{noauthor_welcome_nodate} test automation framework.
\textit{tox} is an automated testing tool that automatically discovers tests in the codebase and can run the tests in parallel to speed up the develop/test/debug implementation cycle. 
Using \textit{tox} allowed us to setup test configuration files within the code repository to standardise the testing framework. The \textit{Github Actions} running on the repository would then enforce the testing checks on the codebase using these configuration files. 
Team members were assigned to writing tests for new functionality in parallel to their creation. 
This allowed the team to work more efficiently as bugs were spotted earlier and code functionality was verified as it was implemented. 
The allowed other team members to reliably use the code implemented by other team members, with the knowledge that that code will work as expected. 
\textit{tox} can then flag failing tests and highlights the line in the test code at fault, along with any relevant error codes and stack-traces, this allows the developer to quickly pin point the section in their code that is at fault if the test coverage is thorough enough. 
It also reports the overall test coverage on the codebase (Figure \ref{tox-coverage}). 
Test code was implemented in a separate \textit{tests} folder of the repository, with a module structure mirroring that of the main \textit{qcp} code module, so that it was easy to tell which test files corresponded to which implementation code file.

\medskip

Another tool that was used extensively was the IBM Quantum simulator\cite{noauthor_programming_nodate}, this tool was used as a reference implementation of a quantum computer simulator, against which we could compare our calculated quantum gates and quantum circuits, to verify that our quantum algorithms were working as expected.

\subsubsection{Testing Simple functions}

 The first tests that were implemented were to test the tensor product function, this was done in the file \textit{test\_tensor\_product.py}. These tests worked by implementing an array containing a series of matrices of different sizes and contents with the intention of catching corner cases. Then taking the tensor product all these matrices by inputting them into the \textit{numpy.kron()} function in a separate file. The computed values were then placed inside arrays and were compared to the calculated values from our \textit{tensor\_product()} function. Almost all the tests were passed except for the tests with non-square matrices, these bugs were fixed once spotted and the tox command in the terminal let us know that we covered near 100\% of the tensor product code. Similar tests were then constructed for the single qubit gates in the file \textit{test\_gates.py}. Single qubit gates such as the Hadamard were easy to construct tests for since finding the answers to the inputs $\ket{0}$ and $\ket{1}$ was usually enough to prove that the gate worked. We tested code to what we deemed a satisfactory level and only then moved on to the next piece of the project. A helper functions file was introduced to assist with further tests, however the only function that was present in this file was compare matrices which tests if two matrices are roughly equal and uses an assert to be compatible with Tox since it removed rounding errors when calculating matrices. This helper function was used throughout the test files, most notably in the \textit{test\_grovers\_algorithm.py} file and drastically reduced the amount of repeated code.
 
\subsubsection{Testing Grover's Algorithm}

All the individual methods of the \textit{Grovers} class as well as the \textit{pull\_set\_bits()} helper function were tested in the \textit{test\_grovers\_algorithm.py} file. Most of the test functions work the same as described before with a set of expected values being stored in an array whereupon the calculated values from the function was compared and asserted to be compatible with the Tox utility. The above tests of course are directed at a generic Grover's Algorithm in order to test the variations a new file called \textit{test\_Sudoku.py} was created, which also tested all the methods specific to the Sudoku variation on Grover's Algorithm. Tests for other functions such as \textit{register}, \textit{matrix}, \textit{parser}, \textit{usage}, in separate files were created under the same principle. Of course all of this was being developed in parallel to the actual functions to spot bugs sooner and all tests were reported with the Tox utility.

\pagebreak

\section{Coding with Python}
The first step of the project was for the group to choose which language to implement the system with. Options included C, C++, Java, and Haskell, but the final decision was to use Python. This was our language of choice for several reasons: Most of our team has experience with the language making it easier to write the code, the language is object-oriented which means Grover’s Algorithm could be created as an object from a class which reduced the amount of repeated code when several versions of Grover's Algorithm were  implemented. It’s more general-purpose compared to languages such as Haskell or Java (Haskell being a purely functional language, and Java being purely an object oriented language, Python combines necessary features of both), and it uses high-level syntax in comparison to languages like C and C++ making it more appropriate for a high-level task such as this which involves matrix multiplication. However, while Python was it language of choice It was also decided that we would minimise the use of import packages such as numpy. With those restrictions in place, the next step was to implement some basic quantum operations.

\subsection{Tensor Products}

When mathematically representing a quantum computer, qubits are written as column vectors while gates are written as square matrices. To combine a series of gates or qubits their tensor product is taken, therefore a function that takes the tensor product of two matrices in Python is needed to implement Grover's Algorithm. This was done in the \textit{tensor\_product.py} file which contains the function \textit{tensor\_product(A: Matrix, B: Matrix)}. This function takes two objects of the user defined class DefaultMatrix (A and B) as inputs, and outputs their tensor product as a DefaultMatrix object. This was calculated by creating a new empty matrix (C) with a number of columns that is equal to the number of columns that A has multiplied by the number of columns that B has, and with a number of rows that is equal to the number of rows that A has multiplied by the number of rows that B has. This empty matrix is then iterated over itself in a 2D loop with the values in A and B being multiplied together and added to the Matrix C accordingly. This function was used throughout the rest of the project in almost every file and made it possible to construct the circuit for Grover's Algorithm. While some of the team work on this function, other members worked on implementing the first quantum gates.

\subsection{Matrices}
The numpy package usually makes matrix multiplication much easier in Python, however since we had decided to restrict ourselves to not use outside packages we had to create a readable way to multiply matrices together. This was done by creating a new class called \textit{DefaultMatrix} which had matrix multiplication embedded as a method. To create the \textit{DefaultMatrix} class a dummy class called \textit{Matrix} was created which contained dummy methods This class was then taken as an input for two new classes which represented two different notations for a Matrix, these being \textit{DenseMatrix} and \textit{SparseMatrix}. Both of these new classes then overwrote the dummy functions given to them to account for their different notations. A Dense matrix contains all its values in an appropriately shaped 2D array, while a sparse matrix only stores the shape of the matrix as while the rest of the values assumed to be zero. The \textit{SparseMatrix} class saves space for large matrices with only a few values such as larger variations of the control gates. These two classes together more than offset their extra lines of code by allowing the program to run with less memory, therefore it was deemed appropriate. 

\subsection{Gates}
Almost all the necessary single qubit gates can be represented as a constant 2x2 square matrix and then to apply the gate to a single qubit, you multiply the matrix representation of the gate with the vertical phase vector. Rather than creating functions for these gates which would output the same thing every time, we stored all the necessary 2x2 gates (IDENTITY, TWO\_HADAMARD, PAULI\_X, PAULI\_Y) in a file titled \textit{constants.py}. In this file we also stored the state vectors for the single qubit states $\ket{0}$ and $\ket{1}$ as ZERO\_VECTOR and ONE\_VECTOR respectively. 
The decision to use a constants file with these specific constants allowed us to avoid duplicating code and additional computational complexity as we could create more interesting gates using these constants and the tensor product.

\begin{file}[constants.py]
\begin{lstlisting}[language=Python]
#: The 2x2 Identity Matrix
IDENTITY = DefaultMatrix([[1, 0], [0, 1]])
#: The 2x2 Hadamard Gate
TWO_HADAMARD = (1/math.sqrt(2)) * \
	DefaultMatrix([[1, 1], [1, -1]])
#: A Column Vector representing the |0> state
ZERO_VECTOR = DefaultMatrix([[1], [0]])
#: A Column Vector representing the |1> state
ONE_VECTOR = DefaultMatrix([[0], [1]])
#: The 2x2 Pauli-X Gate
PAULI_X = DefaultMatrix([[0, 1], [1, 0]])
#: The 2x2 Pauli-Z Gate
PAULI_Z = DefaultMatrix([[1, 0], [0, -1]])

\end{lstlisting}
\end{file}

The only single qubit gate that did not have a matrix stored in the \textit{constants.py} file was the phase shift gate, since its matrix is not constant and depends on the rotation angle. To account for this a function called \textit{phase\_shift(phi: complex)} was implemented in a new file called \textit{gates.py}, which takes a complex number as an input and outputs a DefaultMatrix representing the phase shift gate of the inputted angle. With the single qubit gates implemented, larger gates can now be constructed from the smaller gates in the remainder of the \textit{gates.py} file.

\begin{file}[def phase\_shift(phi: complex) -> Matrix:]
\begin{lstlisting}[language=Python]
return DefaultMatrix([[1, 0], 
	[0, cmath.exp(1j * phi)]])
\end{lstlisting}
\end{file}



One of the first large gate functions implemented in the \textit{gates.py} file was called \textit{multi\_gate(size: int, targets: List[int], gate: Gate, phi=0j)} which chains multiple single qubit gates together on specified target input qubits by calculating the tensor product of an arbitrary number of matrices. The function takes the following variables as inputs: size (represents the number of qubits in the entire circuit), targets (which qubits the gate applies to), gate (which single qubit gate needs to be applied), and phi (only for phase gates as it represents the angle of rotation). With those inputs the function \textit{multi\_gate(size: int, targets: List[int], gate: Gate, phi=0j)} computes the values of a large matrix by taking the tensor product of the specified gate as a running product in a loop over the number of qubits (size), if the loop index is not currently one of the target qubits it multiplies by an appropriately sized identity matrix instead.

\begin{file}[def multi\_gate(...)-> Matrix:]
\begin{lstlisting}[language=Python]
if gate is Gate.H:
    g = c.TWO_HADAMARD
elif gate is Gate.X:
    g = c.PAULI_X
elif gate is Gate.Z:
    g = c.PAULI_Z
elif gate is Gate.P:
    g = phase_shift(phi)
else:
    return DefaultMatrix.identity(2 ** size)

m: Matrix = DefaultMatrix([[1]])

for i in range(size):
    if i in targets:
        m = tp.tensor_product(g, m)
    else:
        m = tp.tensor_product(c.IDENTITY, m)
return m

\end{lstlisting}
\end{file}


The resultant matrix corresponds to having a a certain single qubit gate acting upon multiple (target) qubits, this will become important because for Grover's Algorithm we will need to use this function to apply Hadamrd gates to every qubit to construct a complete superposition. 

The other gates that were implemented in this file were the control\_x/z/phase gates, these were also introduced as functions and worked by first introducing various assertions, and then creating a matrix with rows and columns of size 2**qubits. The matrix diagonals at first take on the form of an identity matrix, then the function modifies this matrix by swapping the rows that correspond to the target qubits inputted. The function \textit{\_generic\_control(size: int, controls: List[int],target: int, cval: SCALARS)} was introduced which was called in the \textit{ control\_z(size: int, controls: List[int], target: int) } and \textit{control\_phase(size: int, controls: List[int], target: int, phi: complex)} functions. This design choice was made to further reduce the amount of repeated code. With all the necessary quantum gates in place it was now possible to begin implementing Grover’s Algorithm.

\pagebreak

\section{Implementation}

When implementing Grover's Algorithm in Python it was decided to create a file named \textit{grovers\_algorithm.py} this file contains one helper function called \textit{ pull\_set\_bits(n: int )}, which displays the indexes of the number 1 in the base 2 form of the value, and a Class called \textit{Grovers}. Python was chosen partly because it is an object-oriented language, this allowed all the gates specific to Grover’s Algorithm to be stored as methods in the class while the state of the input qubits could be stored as attributes. This improves the code as it allowed variations of Grover's Algorithm to be created as objects without repeating lines. 
\subsection{Grover's Algorithm} \label{Implement Grovers}
\subsubsection{Constructor} \label{constructor}


\begin{file}[def \_\_init\_\_(self, size: int, target\_state: int):]

\begin{lstlisting}[linewidth=15cm,language=Python]
assert size > 1, 
assert target_state < (2 ** size),

self.size = size
self.target = target_state
self.state = self.initial_state()

self.oracle = self.single_target_oracle()
self.diffuser = self.diffusion()
self.max_reflections = math.floor((math.pi/4)*(math.sqrt(2**size)))
self.circuit = self.construct_circuit()
\end{lstlisting}

\end{file}

Above the contents of the class's initialisation method is displayed which takes in two inputs: size (which is the number of qubits that is required), and target\_state (which is the specific number/ element out of 2 \textsuperscript{size} options that the user wants the algorithm to search for). This initialisation method also explicitly defines the order of the number of calls/ steps that the algorithm makes with the variable self.max\_reflections. All of the other attributes are defined through methods in the class and are described as follows.

\subsubsection{Initial State} \label{Initial State}

\begin{file}[def initial\_state(self) -> Matrix:]
\begin{lstlisting}[language=Python]
entries: MATRIX = [[0] for _ in range(2**self.size)]
entries[0][0] = 1
return DefaultMatrix(entries)
\end{lstlisting}
\end{file}

This method is simply to initialise the beginning state of the system as $\ket{0}$ as a DefaultMatrix. The method first creates a column vector representing the value zero as qubit with the size of the column vector being equal to the inputted size. If for example Grover's Algorithm were set to work with three qubits (done by setting the size attribute to three), it would create a column vector of size eight with the first item being the number one and the rest being the number zero which represents the $\ket{0}$ in qubit form. List comprehension makes the code both more compact and efficient, the only thing we need to do after creating a vector of zeros is set the 0th element to the value 1 and return the column vector as a DefaultMatrix

\begin{file}[def single\_target\_oracle(self):]
\begin{lstlisting}[language=Python]
not_placement = (2 ** self.size) - 1 - self.target
t = pull_set_bits(not_placement)

cz = g.control_z(self.size, 
	[i for i in range(0, self.size - 1)],
	self.size - 1)
	
selector = g.multi_gate(self.size, t, g.Gate.X)
oracle = selector * cz
oracle *= selector
return oracle

\end{lstlisting}
\end{file}

As mentioned in \ref{The Oracle}, the oracle gate 'selects' the chosen target state by flipping its phase and leaving the other states untouched. single\_target\_oracle() is the method that returns the matrix representation of the oracle gate for the given target and number of qubits in the Grover's Algorithm instance. It starts by using \textit{pull\_set\_bits(n: int)} which, for a given number n, returns a list of integers. The integers returned are the indexes (from right to left) of each '1' in the binary string representation of n. For example; for n=6, pull\_set\_bits(n: int) will return the list \textit{[1, 2]} as 5 in binary representation is \textit{'110'}.Here pull\_set\_bits(n: int) is used to determine which qubits will be the target of multiple not gates. After creating a control-z gate which 'controls' every qubit but the last and targets the last, the oracle is made by multiplying the series of not gates by the control-z gate and then by the not gates again.



\subsubsection{Diffusion}

\begin{file}[def diffusion(self):]
\begin{lstlisting}[language=Python]
h = g.multi_gate(self.size, 
	[i for i in range(0, self.size)], 
	g.Gate.H)
			
cz = g.control_z(self.size, 
	[i for i in range(0, self.size - 1)], 
	self.size - 1)
			
x = g.multi_gate(self.size, 
	[i for i in range(0, self.size)], 
	g.Gate.X)
			
diff = h * (x * (cz * (x * h)))
return diff

\end{lstlisting}
\end{file}


\textit{diffusion()} is a method that creates the matrix  representation  of the diffusion/ amplitude amplifaction operation in Grover's Algorithm. To create the diffusion operator another Control Z-gate (that takes every qubit but the last as a control and takes the last as a target) is used. Pauli-X gates are then applied on every qubit both before and after the Control-Z gate. Finally, a set of Hadamard gates are applied before the first set of Pauli-X gates and after the second set of Pauli-X gates. The resulting matrix of this multiplication is then returned
 
\subsubsection{Construction and Running}

Now that we've got a method that creates an Oracle and a Diffusion gate the next step is setting up the circuit using the \textit{construct\_circuit()} method shown below.

\begin{file}[def construct\_circuit(self) -> Matrix:]
\begin{lstlisting}[language=Python]
circuit = g.multi_gate(self.size, 
	[i for i in range(0, self.size)],
	g.Gate.H)

while self.max_reflections > 0:
	circuit = self.oracle * circuit
	circuit = self.diffuser * circuit
	self.max_reflections -= 1
	
return circuit

\end{lstlisting}
\end{file}

First the \textit{multi\_gate(...)} function is used to apply a set of Hadamard gates across each qubit to create the superposition of all states required. As mentioned in \ref{constructor}, the total number of 'calls'/ 'steps'/ reflections is proportional to the $\sqrt{N}$ where N = 2\textsuperscript{size}. After the set of Hadamards are created, the Oracle and Diffusion Gate are applied, one after the other \textit{self.max\_reflections} times which would yield the maximum amplitude for our target state as described in \ref{How the Algorithm Works}. The matrix returned by \textit{construct\_circuit()} represents the set of Hadamards followed by the series of Oracle and Diffusion gates.

 If a column vector representing a qubit (such as \textit{self.state()} as mentioned in \ref{Initial State} ) is multiplied by this matrix, the calculation would be representative of Grover's Algorithm before measurement. The only other methods in the class are the \textit{measure(self)} and \textit{run(self)} methods. The \textit{run(self)} method simply multiplies \textit{self.state()} by the Matrix created in the \textit{construct\_circuit(self)} method and stores the value. \textit{measure(self)} simply collapses the superposition of the output of \textit{run()} into a single value but thanks to the probability state manipulation of Grover's Algorithm, the probability of measuring target value that the algorithm is searching for is incredibly high. The \textit{measure(self)} method simply applies weights to each state based on their respective square amplitudes and then randomly chooses a state according to those weightings. 
 \\
 \\
 In conclusion, by creating a Grover's Class we can generate specific oracles and diffusion gates depending on the target value and number of qubits. This Class lead to a simulation of Grover's algorithm, by creating all the gates in separate methods it lead to clean and efficient code that which can then be re-purposed for other searching operations such as finding solutions to Sudoku puzzles. The final step is testing which is explained in detail in the next chapter.

\subsection{A 2x2 Sudoku Solver}

Implementing the 2x2 Sudoku Solver is very similar to the classical Grover's Algorithm but differs in one major way, how the Oracle is constructed. The Oracle must be able to pick out (or rather, change the phase of) solutions to the 2x2 board whilst leaving the other states alone.
%picture{https://drive.google.com/file/d/1KjxtnFO9avCPiL1NdrAxmgZvi6Jx-Qkb/view}

To be able to do this, this circuit is going to need a total of 9 qubits. The first 4 will represent one of each element on the 2x2 Sudoku board, the next 4 will represent one of the 4 rules for the board and the last qubit will act like a verifier which will tell us if the rules have been satisfied.

\subsubsection{Defining the Sudoku Rules} \label{sudoku rules}

%picture{https://drive.google.com/file/d/1TeY8IskmDYT1ZgUDRdDvOoTcLCOyZQQM/view}

The first thing we need to do is establish and define the rules for the inputs such that no adjacent numbers on the board are equal to each other. This means that:
\begin{enumerate}
    \item $V\textsubscript{0}$ cannot be equal to $V\textsubscript{1}$
    \item $V\textsubscript{0}$ cannot be equal to $V\textsubscript{2}$
    \item $V\textsubscript{1}$ cannot be equal to $V\textsubscript{3}$ and, 
    \item $V\textsubscript{2}$ cannot be equal to $V\textsubscript{3}$
\end{enumerate}

This is implemented as follows:

\begin{file}[def sudoku\_conditions(self) -> Matrix:]
\begin{lstlisting}[language=Python]
cond1 = g.control_x(9, [1], 4) * 
            g.control_x(9, [0], 4)
cond2 = g.control_x(9, [2], 5) * 
            g.control_x(9, [0], 5)
cond3 = g.control_x(9, [3], 6) * 
            g.control_x(9, [1], 6)
cond4 = g.control_x(9, [3], 7) * 
            g.control_x(9, [2], 7)

cond = cond4 * cond3 * cond2 * cond1

return cond
\end{lstlisting}
\end{file}

The rules listed 1-4 can be thought of as classical XOR gates acting on the qubits which represent V0-V4 where the result is stored in the condition qubits. Looking at the variable \textit{cond1}, we create an XOR gate by applying two Control-X gates, one with the 0th qubit as the control, the other with the 1st qubit as the control; both results are stored into the 4th qubit, the condition1 qubit. 
We do this for each condition/rule and multiply all the gates together to get one big matrix which will be returned by this function.
%picture{https://drive.google.com/file/d/1SuPpfmKGeyGVaUcrmkuytIuYa-eqeehs/view}

\subsubsection{Oracle}
\begin{file}[def oracle(self) -> Matrix:]
\begin{lstlisting}[language=Python]
had = g.multi_gate(9, [8], g.Gate.H)
z = g.multi_gate(9, [8], g.Gate.Z)
cond = self.sudoku_conditions()
cnot = g.control_x(9, [4, 5, 6, 7], 8)
oracle = cond * cnot * cond
oracle = cond * cnot * cond * z * had
return oracle
\end{lstlisting}
\end{file}

Now that the rules for the sudoku board have been established we now need to implement the oracle gate. This is done in a few short steps:
\begin{itemize}
    \item Firstly, we apply a Hadamard followed by a phase shift gate to the Verifier qubit (the 8th qubit) to get the state $\ket{-} = \ket{0} - \ket{1}$ on the Verifier qubit.
    \item Next, we determine whether all of the conditions have been met by applying a Control-X gate, where all the condition qubits (4-7) are the controls and the Verifier qubit (8) is the target.
    \item Lastly, we reset all the values in the condition qubit such that we can use the Oracle again later without having propagating errors and then return the resulting matrix
\end{itemize}
%picture{https://drive.google.com/file/d/1b4cMPr_nn8Vf-e8P2Tb2u-77xFeZ-EPi/view}

The rest of the 2x2 Sudoku implementation is essentially the same as the classical Grover's Algorithm we went over in \ref{Implement Grovers}; we implement a series of Hadamard gates across the first 4 input qubits, then we apply the Oracle and Diffusion gates a set number of times and finally we measure our states to, hopefully, get a solution to the Sudoku Board.

\subsection{Phase Estimation}
\subsubsection{Constructor}

\begin{file}[def \_\_init\_\_(self, size: int, unitary: Matrix, eigenvector: Matrix):]
\begin{center}
\begin{lstlisting}[linewidth=13cm,language=Python]
assert unitary.unitary, 
self.unitary = unitary

self.auxiliary = eigenvector
self.auxsize = int(math.log2(eigenvector.num_rows))
\end{lstlisting}
\end{center}
\end{file}
The class initialisation defined above sets down the rule for what can be accepted as inputs, namely only unitary gate is accepted. Then, the auxiliary register is initialised to be the input eigenvector. The last line computes the number of qubits required for the auxiliary register.

\subsubsection{Initial State}
\begin{file}[def initial\_state(self) -> Matrix:]
\begin{lstlisting}[language=Python]
init = super().initial_state()
return tp.tensor_product(self.auxiliary, init)
\end{lstlisting}
\end{file}

This method prepares the registers for phase estimation procedure. The first line initialises the main register, using the method already defined by the general algorithm. The method then returns the combined registers, by using tensor product. Note that the auxiliary qubits are more significant (i.e., more left in the binary representation) than the main register.
\pagebreak
\subsubsection{The Hadamards}
\begin{center}
\begin{file}[def first\_layer(self) -> Matrix:]
\begin{lstlisting}[linewidth=14cm][language=Python]
id = g.multi_gate(self.auxsize, [], g.Gate.I)
return tp.tensor_product(
    id,g.multi_gate(self.size, [i for i in range(self.size)],
    g.Gate.H))
\end{lstlisting}
\end{file}
\end{center}

The first part of the phase estimation circuit is the Hadamard operation on the main register, acting on all of the main qubits. The identity matrix for the auxiliary register if first created, then combined with the Hadamard gates for the main register. Note that the auxiliary register is not affected by this operation. 

\subsubsection{Applying Control-U}
\begin{file}[def second\_layer(self) -> Matrix:]
\begin{lstlisting}[linewidth=14cm][language=Python]
totalsize = self.size+self.auxsize
gate = g.multi_gate(totalsize, [], g.Gate.I)
rep = 0
for i in range(0, self.size):
    for j in range(2**rep):
        n = self.size-1-i
        gate = g.control_u(totalsize, n, self.unitary) * gate
        rep += 1
        return gate
\end{lstlisting}
\end{file}
The next part is where the control-U gates repeatedly acts on the auxiliary registers, with the controls set to the least significant qubit to the most significant qubit in sequential order. The total size of the combined register is first calculated, which is required to initialise an identity matrix. The loop in the next section then applies the Control-U gate iteratively to the system, with the repetition increasing by a factor of two for each change in the control qubit. The method then returns the combined matrix.
\pagebreak
\subsubsection{Inverse QFT}
The final part of phase estimation procedure is to apply the inverse QFT gate to the main register. This is split into three different code segments.
\begin{file}[def inverse\_qft\_gate(size: int) -> Matrix:]
\begin{lstlisting}[linewidth=13cm][language=Python]
gate = g.multi_gate(size, [], g.Gate.I)
for i in range(int(size/2)):
    gate = g.swap(size, i, size-i-1)*gate
    for i in range(0, size):
        gate = g.multi_gate(size, [i], g.Gate.H) * \
        inverse_qft_rotation_gate(size, i)*gate
return gate
\end{lstlisting}
\end{file}

The inverse QFT begins with the swap gates performed on the qubit $i$ and qubit $n-i$, where n is the number of qubits in the main register. Then, the rotation gates for the $n^{th}$ qubit are assembled by calling the \texttt{inverse\_qft\_rotation\_gates} method, detailed below. After that, a Hadamard gate is applied to the same qubits. This is repeated for all of the qubits in the main register.

\begin{file}[def inverse\_qft\_rotation\_gate(size: int, current\_qubit: int) -> Matrix:]
\begin{lstlisting}[linewidth=14cm][language=Python]
gate: Matrix = DefaultMatrix.identity(2**size)
for i in range(0, current_qubit):
    phi = -2*math.pi/2**(current_qubit+1-i)
    control = i
    gate = gate * g.control_phase(size, [control], current_qubit
    , phi)
return gate
\end{lstlisting}
\end{file}
Here the rotation gate required for inverse QFT is constructed. Denoting $i$ as the current qubit, we need to apply rotations $R_n R_{n-1}\cdots R_k \cdots R_2$, with the phase being $-\frac{2\pi i}{2^k}$ with $k$ being the subscript of each $R$ and the controls being the $n-k$ qubit.

\pagebreak
\begin{file}[def third\_layer(self):]
\begin{lstlisting}[linewidth=14cm][language=Python]
id = g.multi_gate(self.auxsize, [], g.Gate.I)
return tp.tensor_product(
    id,
    inverse_qft_gate(self.size)
        )
\end{lstlisting}
\end{file}
This class method simply perform tensor product using identity for auxiliary register and the inverse QFT gate for main register.

\subsubsection{Construction and Running}

\begin{file}[def construct\_circuit(self):]
\begin{lstlisting}[linewidth=14cm][language=Python]
first = self.first_layer()
second = self.second_layer()
third = self.third_layer()

return third * second * first
\end{lstlisting}
\end{file}
Now that we got everything ready, we can combine the parts and form the total matrix. The function simply returns the product of all three matrix by summoning the functions defined before this. By multiplying this final matrix with the initial states, we obtain the output state of the phase estimation, ready for measurement.

\pagebreak

\section{Issues and Challenges}

\pagebreak
\section{State of the Art: Quantum Computers}

\noindent
The idea of combining quantum mechanics and information theory appeared in the 1970s, but received little attention until 1981, when physicist Richard Feynman gave a presentation arguing that computation based on classical logic could not process calculations representing quantum phenomena in a tractable manner. %https://www.ncbi.nlm.nih.gov/books/NBK538701/
“Nature isn’t classical, dammit, and if you want to make a simulation of nature, you’d better make it
quantum mechanical”, the physicist Richard Feynman famously quipped. “And by golly it’s a
wonderful problem, because it doesn’t look so easy.” %https://link.springer.com/content/pdf/10.1007/s11432-020-2881-9.pdf#page27
Later in 1994, quantum computing received even more attention when mathematicial Peter Shor developed a quantum algorithm. The algorithm could find the prime factors of large numbers in a time efficient manner, which was far better than the efficiency of the current state-of-the-art of classical algorithms. The press, in the process of popularising quantum computation, often misleads the general public by mediating that the speed gained by quantum computing is by trying every possible  answer to a problem in parallel. In fact, a quantum computer works by considering entanglement between qubits and the probabilities associated with the superpositions to carry out a series of operations, the quantum algorithm, which then enhances certain probabilities and supresses other, leading to the required answer. A measurement is made at the end of the computation, and the algorithm should enhance the probability of measuring the correct answer. This use of entanglement and probabilities sets the quantum computer apart from classical computers. 
% picture

\vspace{5mm}

\noindent
"Quantum Computing" is just a blanket term describing all computations that work based on the quantum phenomena. There are multiple types of frameworks, like a measurement-based computation framework, in which highly entangled qubits serve as the starting point. Single qubit measurements are performed, leaving the target single qubit in a definitive state. Further measurements are carried out on other qubits based on the previous results, until the answer is reached. In this project, we are concerned with Logical or gate-based quantum computing framework. In this framework, qubits are prepared in initial states, which then are subject to a series of gate operations. Through these gates, the qubits are put into superposition, entangled and then subjected to measurement, which then yields a result. 
%https://www.ncbi.nlm.nih.gov/books/NBK538701/
Quantum computers can be implemented using a variety of quantum systems, such as trapped ions, superconducting qubits, photons, and silicon. Over last couple of decades, numerous advances have been attempted to try and build large scale quantum computers. Superconducting qubits, in particular, have emerged as a major possibility for such large scale quantum prcessor architecture.

\noindent
\subsection{Superconducting Quantum Computers}
\noindent
Yasunobu Nakamura, in 1999, produced the first simple qubit for superconducting computing. As a result, superconducting quantum computing has advanced significantly in recent years, with the number of qubits rapidly increasing and the quality of qubits rapidly improving. The major milestone, known as quantum supremacy, represents a significant achievement in paving the way towards quantum computing, was first exhibited using the superconducting quantum systems in 2019. Due to this rapid development in the sector of superconducting quantum computers, the worldwide race towards the quantum computer is in full swing.%https://link.springer.com/content/pdf/10.1007/s11432-020-2881-9.pdf
Many companies like Honeywell, IBM, Google, and Intel are competing for having dominance in the quantum computers region. Up and coming players like IonQ and Rigetti have also stepped into the field to advance the technology. While the field is still evolving, there have been some major advancements by these companies in the fields like pharmaceutical and chemical industries, risk in the finance industry, and aid in cybersecurity across a multitude of industries, suing the power of quantum computation.   %https://www.forbes.com/sites/danielnewman/2022/01/10/quantum-computing-expanded-in-2021-setting-up-a-big-2022/?sh=64386df4581b 
All of these initiatives have resulted in a bright future for superconducting quantum computing. %https://link.springer.com/content/pdf/10.1007/s11432-020-2881-9.pdf
\subsection{Quantum Supremacy}
The goal of quantum supremacy is to show that a programmable quantum device can solve a problem that classical computers cannot solve. in 2019, Google officially made the announcement of the achievement of this milestone.  
%https://link.springer.com/content/pdf/10.1007/s11432-020-2881-9.pdf#page27

%picture
%https://www.nature.com/articles/d41586-019-03213-z

\subsection{IBM: 127 qubit eagle processor}
IBM, on November 16, 2021, announced its new 127-qubit 'Eagle' processor at the IBM Quantum Summit 2021, the annual event held by IBM to showcase their milestones in quantum hardware, software, and the growth of the quantum ecosystem. 'Eagle' is IBM's first quantum processor developed and deployed to contain more than 100 operational and connected qubits. It is preceded by IBM's 65-qubit 'Hummingbird' processor released in 2020 and the 27-qubit 'Falcon' processo released in 2019.

\noindent
The new techniques used within Eagle apply control wiring on multiple physical levels within the processor, keeping the qubits on a single layer, which enables a significant increase in qubits.

%https://newsroom.ibm.com/2021-11-16-IBM-Unveils-Breakthrough-127-Qubit-Quantum-Processor
\pagebreak
\section{Conclusion} % Numbered section

\pagebreak
\section{References and Bibliography}
\printbibliography[heading=none]

\end{document}
https://www.overleaf.com/project/621f925c52bf57288226281e